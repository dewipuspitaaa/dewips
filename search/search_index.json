{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Selamat Datang di Halaman Komputasi Numerik \u00b6 Profil \u00b6 Nama: Dewi Puspita Sari NIM: 180411100113 Kelas: Komputasi Numerik 4A Program Studi: Teknik Informatika Dosen Pengampu: Mula'ab, S.Si, M.Kom","title":"Home"},{"location":"#selamat-datang-di-halaman-komputasi-numerik","text":"","title":"Selamat Datang di Halaman Komputasi Numerik"},{"location":"#profil","text":"Nama: Dewi Puspita Sari NIM: 180411100113 Kelas: Komputasi Numerik 4A Program Studi: Teknik Informatika Dosen Pengampu: Mula'ab, S.Si, M.Kom","title":"Profil"},{"location":"tugas1/","text":"Menghitung Nilai [e^{}] dengan Pendekatan Deret MacLaurin \u00b6 Deret Taylor dan Deret MacLaurin Sebuah fungsi F(x) yang memiliki turunan F^{1}(x),F^{2}(x),F^{3}(x) dan seterusnya kontiyu dalam interval I dan a,xI maka x disekitar a yang [x-a]<f(x) dapat diekspansi kedalam Deret Taylor. Deret Taylor didefinisikan sebagai berikut. $$ (x)=f(a)=\\frac{f^{1}a(x-a)}{1!}+\\frac{f^{2}a(x-a)^2}{2!}+\\frac{x^{3}a(x-a)^3}{3!}...\\frac{f^{n}a(x-a)^n}{n!} $$ Deret MarcLaurin masih berhubungan dengan Deret Taylor. Deret MacLaurin merupakan kasusu dari deret Tayor dengan fungsi yang di ekspansi di sekitar nilai a=0 . Deret MacLaurin disebut sebagai Deret Taylor Baku, sehingga sebagai berikut. $$ f(x)=f(0)+\\frac{f^{1}(0)x}{1!}+\\frac{f^{2}(0)x^2}{2!}+\\frac{f^{3}(0)x^3}{3!}...\\frac{f^{n}(0)x^n}{n!} $$ Dalam deret macLauren yaitu menunjukkan tiap-tiap suku sampai batas yang ditentukan, sehingga akan menghasilkan nilai yang mendekati nilai yang sebenarnya. Deret MacLauren ini di manfaatkan dalam metode numerik untuk menghitung atau menghampiri nilai fungsi susah dihitung secara manual, seperti halnya kita ingin mencari nilai dari sinx, cosx, e^{x}, logx atau ln(x+1) . Kita membutuhkan alat khusus, seperti kalkulator atau tabel khusus untuk mencari nilai-nilai dari fungsi tersebut. Implementasi import math error = 0.001 def percent ( angka ): return str ( round ( angka * 100 , 4 )) + '%' def f ( x ): f_turunan = 1 current = i = 0 iteration = True while iteration : old = current current += ( f_turunan * ( x ** i )) / math . factorial ( i ) #\u03a3f(0)x^i / i! print ( 'f ke-' , i , '=' , f_turunan , ' {e^3x=' , current , '} {Ea=' , current - old , '} {|\u03f5a|%=' , ( current - old ) / current , '|' , percent (( current - old ) / current ), '}' ) if current - old < error : iteration = False else : f_turunan *= 3 i += 1 f ( 1 ) `f ke- 0 = 1 {e^3x= 1.0 } {Ea= 1.0 } {|\u03f5a|%= 1.0 | 100.0% }` `f ke- 1 = 3 {e^3x= 4.0 } {Ea= 3.0 } {|\u03f5a|%= 0.75 | 75.0% }` `f ke- 2 = 9 {e^3x= 8.5 } {Ea= 4.5 } {|\u03f5a|%= 0.5294117647058824 | 52.9412% }` `f ke- 3 = 27 {e^3x= 13.0 } {Ea= 4.5 } {|\u03f5a|%= 0.34615384615384615 | 34.6154% }` `f ke- 4 = 81 {e^3x= 16.375 } {Ea= 3.375 } {|\u03f5a|%= 0.20610687022900764 | 20.6107% }` `f ke- 5 = 243 {e^3x= 18.4 } {Ea= 2.0249999999999986 } {|\u03f5a|%= 0.11005434782608689 | 11.0054% }` `f ke- 6 = 729 {e^3x= 19.412499999999998 } {Ea= 1.0124999999999993 } {|\u03f5a|%= 0.05215711526078554 | 5.2157% }` `f ke- 7 = 2187 {e^3x= 19.846428571428568 } {Ea= 0.4339285714285701 } {|\u03f5a|%= 0.02186431527802765 | 2.1864% }` `f ke- 8 = 6561 {e^3x= 20.009151785714284 } {Ea= 0.162723214285716 } {|\u03f5a|%= 0.008132439397150944 | 0.8132% }` `f ke- 9 = 19683 {e^3x= 20.063392857142855 } {Ea= 0.05424107142857082 } {|\u03f5a|%= 0.0027034844911218605 | 0.2703% }` `f ke- 10 = 59049 {e^3x= 20.079665178571425 } {Ea= 0.016272321428569825 } {|\u03f5a|%= 0.0008103880858499218 | 0.081% }` `f ke- 11 = 177147 {e^3x= 20.08410308441558 } {Ea= 0.004437905844156376 } {|\u03f5a|%= 0.00022096609569784593 | 0.0221% }` `f ke- 12 = 531441 {e^3x= 20.08521256087662 } {Ea= 0.001109476461039094 } {|\u03f5a|%= 5.523847246706314e-05 | 0.0055% }` ` f ke - 13 = 1594323 { e ^ 3 x = 20.08546859390609 } { Ea = 0.0002560330294691937 } { | \u03f5 a |%= 1.2747177307422833e-05 | 0.0013 % }","title":"MacLaurin"},{"location":"tugas1/#menghitung-nilai-91e93-dengan-pendekatan-deret-maclaurin","text":"Deret Taylor dan Deret MacLaurin Sebuah fungsi F(x) yang memiliki turunan F^{1}(x),F^{2}(x),F^{3}(x) dan seterusnya kontiyu dalam interval I dan a,xI maka x disekitar a yang [x-a]<f(x) dapat diekspansi kedalam Deret Taylor. Deret Taylor didefinisikan sebagai berikut. $$ (x)=f(a)=\\frac{f^{1}a(x-a)}{1!}+\\frac{f^{2}a(x-a)^2}{2!}+\\frac{x^{3}a(x-a)^3}{3!}...\\frac{f^{n}a(x-a)^n}{n!} $$ Deret MarcLaurin masih berhubungan dengan Deret Taylor. Deret MacLaurin merupakan kasusu dari deret Tayor dengan fungsi yang di ekspansi di sekitar nilai a=0 . Deret MacLaurin disebut sebagai Deret Taylor Baku, sehingga sebagai berikut. $$ f(x)=f(0)+\\frac{f^{1}(0)x}{1!}+\\frac{f^{2}(0)x^2}{2!}+\\frac{f^{3}(0)x^3}{3!}...\\frac{f^{n}(0)x^n}{n!} $$ Dalam deret macLauren yaitu menunjukkan tiap-tiap suku sampai batas yang ditentukan, sehingga akan menghasilkan nilai yang mendekati nilai yang sebenarnya. Deret MacLauren ini di manfaatkan dalam metode numerik untuk menghitung atau menghampiri nilai fungsi susah dihitung secara manual, seperti halnya kita ingin mencari nilai dari sinx, cosx, e^{x}, logx atau ln(x+1) . Kita membutuhkan alat khusus, seperti kalkulator atau tabel khusus untuk mencari nilai-nilai dari fungsi tersebut. Implementasi import math error = 0.001 def percent ( angka ): return str ( round ( angka * 100 , 4 )) + '%' def f ( x ): f_turunan = 1 current = i = 0 iteration = True while iteration : old = current current += ( f_turunan * ( x ** i )) / math . factorial ( i ) #\u03a3f(0)x^i / i! print ( 'f ke-' , i , '=' , f_turunan , ' {e^3x=' , current , '} {Ea=' , current - old , '} {|\u03f5a|%=' , ( current - old ) / current , '|' , percent (( current - old ) / current ), '}' ) if current - old < error : iteration = False else : f_turunan *= 3 i += 1 f ( 1 ) `f ke- 0 = 1 {e^3x= 1.0 } {Ea= 1.0 } {|\u03f5a|%= 1.0 | 100.0% }` `f ke- 1 = 3 {e^3x= 4.0 } {Ea= 3.0 } {|\u03f5a|%= 0.75 | 75.0% }` `f ke- 2 = 9 {e^3x= 8.5 } {Ea= 4.5 } {|\u03f5a|%= 0.5294117647058824 | 52.9412% }` `f ke- 3 = 27 {e^3x= 13.0 } {Ea= 4.5 } {|\u03f5a|%= 0.34615384615384615 | 34.6154% }` `f ke- 4 = 81 {e^3x= 16.375 } {Ea= 3.375 } {|\u03f5a|%= 0.20610687022900764 | 20.6107% }` `f ke- 5 = 243 {e^3x= 18.4 } {Ea= 2.0249999999999986 } {|\u03f5a|%= 0.11005434782608689 | 11.0054% }` `f ke- 6 = 729 {e^3x= 19.412499999999998 } {Ea= 1.0124999999999993 } {|\u03f5a|%= 0.05215711526078554 | 5.2157% }` `f ke- 7 = 2187 {e^3x= 19.846428571428568 } {Ea= 0.4339285714285701 } {|\u03f5a|%= 0.02186431527802765 | 2.1864% }` `f ke- 8 = 6561 {e^3x= 20.009151785714284 } {Ea= 0.162723214285716 } {|\u03f5a|%= 0.008132439397150944 | 0.8132% }` `f ke- 9 = 19683 {e^3x= 20.063392857142855 } {Ea= 0.05424107142857082 } {|\u03f5a|%= 0.0027034844911218605 | 0.2703% }` `f ke- 10 = 59049 {e^3x= 20.079665178571425 } {Ea= 0.016272321428569825 } {|\u03f5a|%= 0.0008103880858499218 | 0.081% }` `f ke- 11 = 177147 {e^3x= 20.08410308441558 } {Ea= 0.004437905844156376 } {|\u03f5a|%= 0.00022096609569784593 | 0.0221% }` `f ke- 12 = 531441 {e^3x= 20.08521256087662 } {Ea= 0.001109476461039094 } {|\u03f5a|%= 5.523847246706314e-05 | 0.0055% }` ` f ke - 13 = 1594323 { e ^ 3 x = 20.08546859390609 } { Ea = 0.0002560330294691937 } { | \u03f5 a |%= 1.2747177307422833e-05 | 0.0013 % }","title":"Menghitung Nilai [e^{}] dengan Pendekatan Deret MacLaurin"},{"location":"tugas2/","text":"Fungsi Persamaan Non Linier dengan Metode Newton Raphson \u00b6 Penyelesaian persamaan non linier adalah penentuan akar-akar persamaan non linier. Dimana akar sebuah persamaan f(x) =0 adalah nilai-nilai x yang menyebabkan nilai f(x) sama dengan nol. Dengan kata lain akar persamaan f(x) adalah titik potong antara kurva f(x) dan sumbu X . Beberapa persamaan polynomial yang sederhana dapat diselesaikan theorema sisa. Sehingga tidak memerlukan metode numerik dalam menyelesaikannya, karena metode analitik dapat dilakukan. Tetapi bagaimana menyelesaikan persamaan \u200b $$ x\u2013 e-x = 0 $$ Tampaknya sederhana, tetapi untuk menyelesaikan persamaan non linier merupakan metode pencarian akar secara berulang-ulang. Secara sederhana, untuk menyelesaikan persamaan non linier dapat dilakukan dengan menggunakan metode tabel atau pembagian area. Dimana untuk x = [ a , b ] atau x di antara a dan b dibagi sebanyak N bagian dan pada masing-masing bagian dihitung nilai f(x) bila ditemukan f(xk)=0 atau mendekati nol maka dikatakan bahwa xk adalah penyelesaian persamaan f(xk)=0 . Bila tidak ada f(xk) yang sama dengan nol, maka dicari nilai f(xk) dan f(xk+1) yang berlawanan tanda, bila tidak ditemukan maka, f(a).f(b)<0 pada range x=[a,b] terdapat akar f(a).f(b)>0 pada range x=[a,b] dikatakan tidak mempunyai akar untuk x = [ a , b ] dan bila ditemukan maka ada 2 pendapat untuk menentukan akar persamaan, yaitu : Akar persamaan ditentukan oleh nilai mana yang lebih dekat, bila |f(xk)| \u2264 |f(xk+1)| maka akarnya xk , dan bila |f(xk+1)|<|f(xk)| maka akarnya xk+1. Akarnya perlu di cari lagi, dengan range x = [ ] xk , xk +1 Metode Newton Raphson \u00b6 Metode newton raphson adalah metode pendekatan yang menggunakan satu titik awal dan mendekatinya dengan memperhatikan slope atau gradien pada titik tersebut. Algoritma Metode Newton Raphson Mendefinisikan fungsi f(x) dan f1(x) Menentukan toleransi error (e) dan iterasi maksimum ( n ) Menentukan nilai pendekatan awal x0 Menghitung f(x0) dan f1(x0) Untuk iterasi I= 1 atau |f(xi)|\u2265 e, akar persamaan adalah nilai xi yang terakhir diperoleh. $$ x_{n+1} = x_{n} + \\frac{F(x_{n})}{F^{1}(x_{n})} $$ Algoritma Metode Newton Raphson dengan modifikasi tabel : Mendefinisikan fungsi F(x) Mengambil range nilai x =[ a , b ] dengan jumlah pembagi n Memasukkan torelansi error ( e ) dan masukkan iterasi n Menggunakan algoritma tabel diperoleh titik pendekatan awal x0 dari : F(xk) . F(xk+1)<0 maka x0 = xk Hitung F(x0) dan F1(x0) Bila F ( abs ( F ( x 0 )))< e ,maka pendekatan awal x0 digeser sebesar dx (dimasukkan) x0 = x0 + dx , hitung F(x0) dan F1(x0)* Untuk iterasi I= 1 atau |F(xi)|\u2265 e Akar persamaan adalah x terakhir yang diperoleh. #### Implementasi import math e = 2.71828 def fungsi ( x ): x = float (( e ** x ) - ( 4 * x )) return x def fungsiturunan ( x ): x = float (( e ** x ) - ( 4 )) return x x = float ( input ( 'Masukkan nilai awal = ' )) error = float ( input ( 'Masukkan nilai error = ' )) perulangan = int ( input ( 'Masukkan maksimal pengulangan = ' )) iterasi = 0 selisih = error + 1 while iterasi <= perulangan and selisih > error : iterasi += 1 f_2 = x - ( fungsi ( x ) / fungsiturunan ( x )) selisih = math . fabs ( f_2 - x ) x = f_2 print ( \"Iterasi ke = \" , iterasi , \", x = \" , f_2 , \", f(\" , f_2 , \") = \" , fungsi ( f_2 ), \", selisih = \" , error ) if iterasi <= perulangan : print ( \"Perulangan Mencapai Batas Maksimal dengan hasil = \" , f_2 ) else : print ( \"Toleransi tidak terpenuhi\" ) Masukkan nilai awal = 1 Masukkan nilai error = 0.0001 Masukkan maksimal pengulangan = 2 Iterasi ke = 1 , x = 0.0 , f ( 0.0 ) = 1.0 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.0 Iterasi ke = 2 , x = 0.3333333333333333 , f ( 0.3333333333333333 ) = 0.06227877883196098 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3333333333333333 Iterasi ke = 3 , x = 0.35724635301940616 , f ( 0.35724635301940616 ) = 0.0004022049593612742 , selisih = 0.0001 Toleransi tidak terpenuhi Penjelasan \u00b6 Importh Library math karena kita menggunakan contoh fungsi f(x)=ex\u22124Xf(x)=ex\u22124X maka kita membuat sebuah fungsi yang sesuai , dan juga fungsi turunannya yaitu f\u2032(x)=ex\u22124f\u2032(x)=ex\u22124 Membuat sebuah inputan untuk X , Error / Epsilon , serta Maksimal perulangan untuk stopping condition lalu deklarasikan iterasi = 0 untuk perulangan yang ke 0 nantinya dan akan ditambah setiap kali perulangan deklarasikan selisih untuk xb\u2212x0xb\u2212x0 untuk perbandingan lakukan perulangan dengan kondisi iterasi kurang dari sama dengan inputan maksimal iterasi dan selisih lebih dari error / epsilon hitung xbxb dengan rumus yang sudah kita dapatkan sebelumnya lalu lakukan perbandingan jika mencapai nilai True maka toleransi tidak terpenuhi namun perulangan sudah mencapai batas jika pengecekan selisih > error bernilai bernilai True maka toleransi akan terpenuhi dengan nilai error serta fungsi x pada iterasi ke n","title":"Metode Raphson"},{"location":"tugas2/#fungsi-persamaan-non-linier-dengan-metode-newton-raphson","text":"Penyelesaian persamaan non linier adalah penentuan akar-akar persamaan non linier. Dimana akar sebuah persamaan f(x) =0 adalah nilai-nilai x yang menyebabkan nilai f(x) sama dengan nol. Dengan kata lain akar persamaan f(x) adalah titik potong antara kurva f(x) dan sumbu X . Beberapa persamaan polynomial yang sederhana dapat diselesaikan theorema sisa. Sehingga tidak memerlukan metode numerik dalam menyelesaikannya, karena metode analitik dapat dilakukan. Tetapi bagaimana menyelesaikan persamaan \u200b $$ x\u2013 e-x = 0 $$ Tampaknya sederhana, tetapi untuk menyelesaikan persamaan non linier merupakan metode pencarian akar secara berulang-ulang. Secara sederhana, untuk menyelesaikan persamaan non linier dapat dilakukan dengan menggunakan metode tabel atau pembagian area. Dimana untuk x = [ a , b ] atau x di antara a dan b dibagi sebanyak N bagian dan pada masing-masing bagian dihitung nilai f(x) bila ditemukan f(xk)=0 atau mendekati nol maka dikatakan bahwa xk adalah penyelesaian persamaan f(xk)=0 . Bila tidak ada f(xk) yang sama dengan nol, maka dicari nilai f(xk) dan f(xk+1) yang berlawanan tanda, bila tidak ditemukan maka, f(a).f(b)<0 pada range x=[a,b] terdapat akar f(a).f(b)>0 pada range x=[a,b] dikatakan tidak mempunyai akar untuk x = [ a , b ] dan bila ditemukan maka ada 2 pendapat untuk menentukan akar persamaan, yaitu : Akar persamaan ditentukan oleh nilai mana yang lebih dekat, bila |f(xk)| \u2264 |f(xk+1)| maka akarnya xk , dan bila |f(xk+1)|<|f(xk)| maka akarnya xk+1. Akarnya perlu di cari lagi, dengan range x = [ ] xk , xk +1","title":"Fungsi Persamaan Non Linier dengan Metode Newton Raphson"},{"location":"tugas2/#metode-newton-raphson","text":"Metode newton raphson adalah metode pendekatan yang menggunakan satu titik awal dan mendekatinya dengan memperhatikan slope atau gradien pada titik tersebut. Algoritma Metode Newton Raphson Mendefinisikan fungsi f(x) dan f1(x) Menentukan toleransi error (e) dan iterasi maksimum ( n ) Menentukan nilai pendekatan awal x0 Menghitung f(x0) dan f1(x0) Untuk iterasi I= 1 atau |f(xi)|\u2265 e, akar persamaan adalah nilai xi yang terakhir diperoleh. $$ x_{n+1} = x_{n} + \\frac{F(x_{n})}{F^{1}(x_{n})} $$ Algoritma Metode Newton Raphson dengan modifikasi tabel : Mendefinisikan fungsi F(x) Mengambil range nilai x =[ a , b ] dengan jumlah pembagi n Memasukkan torelansi error ( e ) dan masukkan iterasi n Menggunakan algoritma tabel diperoleh titik pendekatan awal x0 dari : F(xk) . F(xk+1)<0 maka x0 = xk Hitung F(x0) dan F1(x0) Bila F ( abs ( F ( x 0 )))< e ,maka pendekatan awal x0 digeser sebesar dx (dimasukkan) x0 = x0 + dx , hitung F(x0) dan F1(x0)* Untuk iterasi I= 1 atau |F(xi)|\u2265 e Akar persamaan adalah x terakhir yang diperoleh. #### Implementasi import math e = 2.71828 def fungsi ( x ): x = float (( e ** x ) - ( 4 * x )) return x def fungsiturunan ( x ): x = float (( e ** x ) - ( 4 )) return x x = float ( input ( 'Masukkan nilai awal = ' )) error = float ( input ( 'Masukkan nilai error = ' )) perulangan = int ( input ( 'Masukkan maksimal pengulangan = ' )) iterasi = 0 selisih = error + 1 while iterasi <= perulangan and selisih > error : iterasi += 1 f_2 = x - ( fungsi ( x ) / fungsiturunan ( x )) selisih = math . fabs ( f_2 - x ) x = f_2 print ( \"Iterasi ke = \" , iterasi , \", x = \" , f_2 , \", f(\" , f_2 , \") = \" , fungsi ( f_2 ), \", selisih = \" , error ) if iterasi <= perulangan : print ( \"Perulangan Mencapai Batas Maksimal dengan hasil = \" , f_2 ) else : print ( \"Toleransi tidak terpenuhi\" ) Masukkan nilai awal = 1 Masukkan nilai error = 0.0001 Masukkan maksimal pengulangan = 2 Iterasi ke = 1 , x = 0.0 , f ( 0.0 ) = 1.0 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.0 Iterasi ke = 2 , x = 0.3333333333333333 , f ( 0.3333333333333333 ) = 0.06227877883196098 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3333333333333333 Iterasi ke = 3 , x = 0.35724635301940616 , f ( 0.35724635301940616 ) = 0.0004022049593612742 , selisih = 0.0001 Toleransi tidak terpenuhi","title":"Metode Newton Raphson"},{"location":"tugas2/#penjelasan","text":"Importh Library math karena kita menggunakan contoh fungsi f(x)=ex\u22124Xf(x)=ex\u22124X maka kita membuat sebuah fungsi yang sesuai , dan juga fungsi turunannya yaitu f\u2032(x)=ex\u22124f\u2032(x)=ex\u22124 Membuat sebuah inputan untuk X , Error / Epsilon , serta Maksimal perulangan untuk stopping condition lalu deklarasikan iterasi = 0 untuk perulangan yang ke 0 nantinya dan akan ditambah setiap kali perulangan deklarasikan selisih untuk xb\u2212x0xb\u2212x0 untuk perbandingan lakukan perulangan dengan kondisi iterasi kurang dari sama dengan inputan maksimal iterasi dan selisih lebih dari error / epsilon hitung xbxb dengan rumus yang sudah kita dapatkan sebelumnya lalu lakukan perbandingan jika mencapai nilai True maka toleransi tidak terpenuhi namun perulangan sudah mencapai batas jika pengecekan selisih > error bernilai bernilai True maka toleransi akan terpenuhi dengan nilai error serta fungsi x pada iterasi ke n","title":"Penjelasan"},{"location":"tugas3/","text":"Sistem Persamaan Linier \u00b6 Metode Eliminasi Gauss \u00b6 Metode eliminasi Gauss adalah metode yang dikembangkan dari metode eliminasi yaitu dengan menghilangkan atau mengurangi jumlah variabel sehingga dapat diperoleh nilai dari suatu variabel bebas. Metode Gauss ini digunakan untuk menyelesaikan sebuah sistem persamaan linier dengan mengubah SPL (Sistem Persamaan Linier) tersebut kedalam bentuk sistem persamaan linier berbentuk segitiga atas, yakni yang semua koefisien dibawah diagonal utamanya bernilai nol. Bentuk segitiga atas ini dapat diselesaikan dengan menggunakan subtitusi. Sebelum merubah menjadi matriks segitiga atas, matriks harus dirubah menjadi augmented matriks : Augmented (A) = [A B] augmented matriks dirubah menjadi matriks segitiga atas dengan menggunakan OBE (Operasi Baris Elementer), seperti persamaan berikut : Maka didapatkan penyeleseaian sebagai berikut : $$ x_{n}= \\frac{b_{n} }{a_{n,n}} $$ Implementasi Pemrograman \u00b6 Berikut program untuk persamaan linier dibawah ini: 1 . 3x + y + 2z = 4 2 . 3x + 3y + z = 5 3 . 2x + y + 2z = 2 Listing Program : import numpy as np #Definisi Matrix A = [] B = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) A.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) B.append(h) Matrix=np.array(A,float) Hasil=np.array(B,float) n=len(Matrix) #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) #Subtitusi x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai X ',m+1, '=',x[m]) Output : Masukkan ukuran Matrix : 3 Masukkan Nilai : 3 Masukkan Nilai : 1 Masukkan Nilai : 2 Masukkan Nilai : 3 Masukkan Nilai : 3 Masukkan Nilai : 1 Masukkan Nilai : 2 Masukkan Nilai : 1 Masukkan Nilai : 2 Masukkan Hasil : 4 Masukkan Hasil : 5 Masukkan Hasil : 2 Matrix A : [[ 3. 1. 2. ] [ 0. 2. - 1. ] [ 0. 0. 0.83333333 ]] Nilai X 3 = - 0.9999999999999998 Nilai X 2 = 1.1102230246251565e-16 Nilai X 1 = 2.0 Metode Gauss Jacobi \u00b6 Metode iterasi Jacobi merupakan salah satu metode tak langsung, yang bermula dari suatu hampiran penyelesaian awal dan kemudian memperbaiki hampiran dalam tak berhingga namun langkah kovergen. Metode iterasi Jacobi ini digunakan untuk menyelesaikan persamaan linier berukuran besar dan proporsi keofeisian nolnya besar. Jika diubah dari persamaan linier, maka akan menjadi : Ax=b Ax=b diketahui bahwa matriks A dapat dituliskan sebagai A=L+D+U, dengan L adalah matriks segitiga bawah, D adalah matriks diagonal, dan U adalah matriks segitiga atas. Lalu persamaan tersebut diubah menjadi : $$ Dx + (L + U)x = B $$ x = D^{-1}[b-(L +U)x] x = D^{-1}[b-(L +U)x] Jika ditulis dalam aturan iteratif, maka metode iterai Jacobi dapat ditulis sebagai berikut: $$ X^{(k)}=D^-1(b-(L+U)X^{(k-1)} $$ Dimana k merupakan banyaknya iterasi. Jika x^{(k)} x^{(k)} menyatakan hampiran ke -k -k penyelesaian SPL, maka x^{(0)} x^{(0)} adalah hampiran awal. x_{i}^{(k)}=\\frac{1}{a_{ii}}(\\sum x^{n}_{j\\ne i}),i = 1,2,...n;k=1,2,3,..., x_{i}^{(k)}=\\frac{1}{a_{ii}}(\\sum x^{n}_{j\\ne i}),i = 1,2,...n;k=1,2,3,..., Suatu matriks A berukuran nxn nxn dikatakan dominan secara diagonal apabila : $$ |a_{ii}|>|a_{i,1}|+...+|a_{i,i-1}|+|a_{i,i+1}|+...+|a_{in}| $$ untuk i =1,2,3,...,n i =1,2,3,...,n Implementasi Pemrograman \u00b6 Berikut program untuk persamaan linier dibawah ini: 1 . 3x + y + 2z = 4 2 . 3x + 3y + z = 5 3 . 2x + y + 2z = 2 Listing Program from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol ) Output: Masukkan ukuran Matrix : 3 Masukkan Nilai : 3 Masukkan Nilai : 1 Masukkan Nilai : 2 Masukkan Nilai : 3 Masukkan Nilai : 3 Masukkan Nilai : 1 Masukkan Nilai : 2 Masukkan Nilai : 1 Masukkan Nilai : 2 Masukkan Hasil : 4 Masukkan Hasil : 5 Masukkan Hasil : 2 A : array ([[ 3. , 1. , 2. ], [ 3. , 3. , 1. ], [ 2. , 1. , 2. ]]) b : array ([ 4. , 5. , 2. ]) x : array ([ 105.35701362 , 119.25506258 , 130.92310531 ]) Metode Gauss Seidel \u00b6 Metode Gauss Seidel digunakan untuk menyelesaikan sistem persamaan linier (SPL) berukuran besar dan proporsi koefisien nolnya besar, seperti sistem-sistem yang banyak ditemukan dalam sistem persamaan diferensial. Metode iterasi Gauss Seidel dikembangkan dari gagasan metode iterasi pada solusi persamaan tak linier. Dengan metode Gauss seidel sesatan pembultan dapat diperkecil karena dapat meneruskan iterasi sampai solusinya seteliti mungkin sesuai dengan batass sesatan yang diperbolehkan. Rumus iterasi untuk hampiran ke-k pada metode Gauss Seidel adalah sebagai berikut. Untuk i=1,2,...,n i=1,2,...,n dan k=1,2,3,... k=1,2,3,... $$ x_{i}^{(k)} = \\frac{1}{a_{ii}}(b_{i} - \\sum_{j=1}^{i-1}a_{ij}x_{j}^{(k)} - \\sum_{j=i+1}^{n}a_{ij}x_{j}^{(k-1)}) $$ dengan syarat a_{ii} \\neq 0 a_{ii} \\neq 0 . Metode iterasi Gauss-Seidel dapat dinyatakan dalam bentuk matriks. Nyatakan matriks koefisien A sebagai A=D+(L+U) A=D+(L+U) , dengan L dan U berturut-turut adalah matriks segitiga bawah dan atas dengandiagonal nol dan D matriks diagonal. Rumus iterasi Gauss-Seidel dapat ditulis dalam bentuk : $$ X^{(k)}=D-1(b-LX^{(k)}-UX^{(k-1)} $$ \\rightarrow (D+L)x^{(k)} = b-Ux^{(k-1)} \\rightarrow (D+L)x^{(k)} = b-Ux^{(k-1)} \\rightarrow x^{(k)} = (D+L)^{-1}(b-Ux^{(k-1)}) \\rightarrow x^{(k)} = (D+L)^{-1}(b-Ux^{(k-1)}) yang menghasilkan: $$ X^{(k)}=(D+L)^{-1} UX^{(k-1)}+(D+L)^{-1}b) $$ Metode iterasi Gauss-Seidel hampir sama dengan metode iterasi Jacobi. Perbedaannya hanya terletak pada penggunaan nilai elemen vektor x^{baru} x^{baru} yang langsung digunakan pada persamaan di bawahnya. Implementasi Pemrograman \u00b6 Berikut program untuk persamaan linier dibawah ini: 1 . 3x + y + 2z = 4 2 . 3x + 3y + z = 5 3 . 2x + y + 2z = 2 Listing Program : def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) print ( x ) Output: Masukkan Panjang Matrix : 3 Masukkan a1 , 1 : 3 Masukkan a1 , 2 : 1 Masukkan a1 , 3 : 2 Masukkan Hasil : 4 Masukkan a2 , 1 : 3 Masukkan a2 , 2 : 3 Masukkan a2 , 3 : 1 Masukkan Hasil : 5 Masukkan a3 , 1 : 2 Masukkan a3 , 2 : 1 Masukkan a3 , 3 : 2 Masukkan Hasil : 2 [ 0 , 0 , 0 ] [ 1.3333333333333333 , 0.3333333333333333 , - 0.4999999999999999 ] [ 1.5555555555555554 , 0.27777777777777796 , - 0.6944444444444443 ] [ 1.7037037037037035 , 0.19444444444444453 , - 0.8009259259259258 ] [ 1.802469135802469 , 0.1311728395061731 , - 0.8680555555555555 ] [ 1.8683127572016458 , 0.08770576131687269 , - 0.9121656378600822 ] [ 1.9122085048010973 , 0.05851337448559687 , - 0.9414651920438957 ] [ 1.941472336534065 , 0.03901606081390022 , - 0.9609803669410151 ] [ 1.9609815576893765 , 0.026011897957628555 , - 0.9739875066681908 ] [ 1.9739877051262509 , 0.017341463763146048 , - 0.982658437007824 ] [ 1.9826584700841672 , 0.011561008918440733 , - 0.9884389745433876 ] [ 1.9884389800561115 , 0.00770734479168426 , - 0.9922926524519536 ] [ 1.9922926533707408 , 0.005138230779910343 , - 0.994861768760696 ] [ 1.994861768913827 , 0.0034254873397382792 , - 0.9965745125836962 ] [ 1.996574512609218 , 0.0022836582520140425 , - 0.997716341735225 ] [ 1.9977163417394788 , 0.0015224388389296628 , - 0.9984775611589436 ] [ 1.9984775611596526 , 0.001014959226661875 , - 0.9989850407729836 ] [ 1.9989850407731018 , 0.000676639484559316 , - 0.9993233605153815 ] [ 1.999323360515401 , 0.00045109298972612066 , - 0.9995489070102641 ] [ 1.9995489070102674 , 0.00030072865982067043 , - 0.9996992713401778 ] [ 1.9996992713401784 , 0.00020048577321415037 , - 0.9997995142267855 ] [ 1.9997995142267857 , 0.0001336571821428656 , - 0.9998663428178571 ] [ 1.9998663428178574 , 8.91047880950957e-05 , - 0.9999108952119049 ] [ 1.9999108952119051 , 5.94031920632491e-05 , - 0.9999405968079368 ] [ 1.999940596807937 , 3.960212804203037e-05 , - 0.9999603978719579 ] [ 1.999960397871958 , 2.6401418694699252e-05 , - 0.9999735985813054 ] [ 1.9999735985813054 , 1.760094579631814e-05 , - 0.9999823990542036 ] [ 1.9999823990542034 , 1.1733963864409466e-05 , - 0.9999882660361356 ] [ 1.9999882660361354 , 7.82264257640867e-06 , - 0.9999921773574236 ] [ 1.9999921773574236 , 5.215095050914442e-06 , - 0.9999947849049491 ] [ 1.999994784904949 , 3.4767300339429616e-06 , - 0.999996523269966 ] [ 1.9999965232699661 , 2.317820022616305e-06 , - 0.9999976821799774 ] [ 1.9999976821799776 , 1.5452133482381687e-06 , - 0.9999984547866517 ] [ 1.9999984547866516 , 1.030142232294473e-06 , - 0.9999989698577678 ] [ 1.9999989698577678 , 6.867614881963154e-07 , - 0.9999993132385119 ] [ 1.999999313238512 , 4.5784099193350397e-07 , - 0.9999995421590081 ] [ 1.9999995421590082 , 3.0522732781997536e-07 , - 0.9999996947726721 ] [ 1.9999996947726721 , 2.0348488523798855e-07 , - 0.9999997965151147 ] [ 1.9999997965151148 , 1.3565659014632322e-07 , - 0.9999998643434099 ] [ 1.99999986434341 , 9.043772660384992e-08 , - 0.9999999095622734 ] [ 1.9999999095622734 , 6.029181776057158e-08 , - 0.9999999397081822 ] [ 1.9999999397081822 , 4.019454517371438e-08 , - 0.9999999598054549 ] [ 1.9999999598054548 , 2.6796363461478734e-08 , - 0.9999999732036364 ] [ 1.9999999732036364 , 1.7864242455682227e-08 , - 0.9999999821357577 ] [ 1.9999999821357577 , 1.1909494797753458e-08 , - 0.999999988090505 ] [ 1.999999988090505 , 7.939663371203665e-09 , - 0.9999999920603367 ] [ 1.9999999920603369 , 5.293108729098606e-09 , - 0.9999999947068912 ] [ 1.9999999947068912 , 3.528739152732404e-09 , - 0.9999999964712607 ] [ 1.9999999964712607 , 2.3524929411896287e-09 , - 0.9999999976475071 ] [ 1.9999999976475074 , 1.5683284300867701e-09 , - 0.9999999984316715 ] [ 1.9999999984316714 , 1.0455524224184387e-09 , - 0.9999999989544477 ] [ 1.9999999989544477 , 6.970349482789592e-10 , - 0.9999999993029651 ] [ 1.9999999993029653 , 4.6468976814632395e-10 , - 0.9999999995353103 ] [ 1.9999999995353104 , 3.097930430702907e-10 , - 0.9999999996902069 ] [ 1.999999999690207 , 2.0652872005181658e-10 , - 0.9999999997934713 ] [ 1.9999999997934712 , 1.3768582570368912e-10 , - 0.9999999998623141 ] [ 1.999999999862314 , 9.179072317048546e-11 , - 0.9999999999082093 ] [ 1.9999999999082094 , 6.119367975306507e-11 , - 0.9999999999388063 ] [ 1.9999999999388063 , 4.079581117366615e-11 , - 0.9999999999592042 ] [ 1.9999999999592042 , 2.7197207449110767e-11 , - 0.9999999999728028 ] [ 1.9999999999728029 , 1.8131459296929126e-11 , - 0.9999999999818686 ] [ 1.9999999999818687 , 1.2087479165738083e-11 , - 0.9999999999879124 ] [ 1.9999999999879126 , 8.058331779636774e-12 , - 0.9999999999919418 ] [ 1.9999999999919418 , 5.372073156687899e-12 , - 0.9999999999946279 ] [ 1.9999999999946276 , 3.581579477440755e-12 , - 0.9999999999964184 ] [ 1.9999999999964182 , 2.3878676813637867e-12 , - 0.9999999999976121 ] [ 1.999999999997612 , 1.5920598173124745e-12 , - 0.9999999999984079 ] [ 1.9999999999984077 , 1.0615212412782664e-12 , - 0.9999999999989385 ] [ 1.9999999999989386 , 7.075451335936123e-13 , - 0.9999999999992923 ] [ 1.9999999999992923 , 4.716967557290749e-13 , - 0.9999999999995282 ] [ 1.9999999999995282 , 3.1463720517876936e-13 , - 0.9999999999996855 ] [ 1.9999999999996856 , 2.095730996150754e-13 , - 0.9999999999997904 ] [ 1.9999999999997904 , 1.3974007136615304e-13 , - 0.9999999999998602 ] [ 1.9999999999998603 , 9.314771176605063e-14 , - 0.999999999999907 ] [ 1.999999999999907 , 6.195044477408373e-14 , - 0.9999999999999379 ] [ 1.9999999999999378 , 4.1485333686826685e-14 , - 0.9999999999999586 ] [ 1.9999999999999585 , 2.7644553313166398e-14 , - 0.9999999999999722 ] [ 1.9999999999999722 , 1.8577731945394287e-14 , - 0.9999999999999816 ] [ 1.9999999999999816 , 1.2212453270876722e-14 , - 0.9999999999999877 ] [ 1.9999999999999876 , 8.326672684688674e-15 , - 0.9999999999999918 ] [ 1.9999999999999918 , 5.551115123125783e-15 , - 0.9999999999999946 ] [ 1.9999999999999947 , 3.515706244646329e-15 , - 0.9999999999999964 ] [ 1.9999999999999964 , 2.3684757858670005e-15 , - 0.9999999999999977 ] [ 1.9999999999999976 , 1.5913196686293911e-15 , - 0.9999999999999983 ] [ 1.9999999999999982 , 1.2212453270876722e-15 , - 0.9999999999999989 ] [ 1.999999999999999 , 8.141635513917814e-16 , - 0.9999999999999993 ] [ 1.9999999999999993 , 3.7007434154171886e-16 , - 0.9999999999999996 ] [ 1.9999999999999993 , 4.440892098500626e-16 , - 0.9999999999999996 ] [ 1.9999999999999993 , 4.440892098500626e-16 , - 0.9999999999999996 ]","title":"Metode Eliminasi Gauss"},{"location":"tugas3/#sistem-persamaan-linier","text":"","title":"Sistem Persamaan Linier"},{"location":"tugas3/#metode-eliminasi-gauss","text":"Metode eliminasi Gauss adalah metode yang dikembangkan dari metode eliminasi yaitu dengan menghilangkan atau mengurangi jumlah variabel sehingga dapat diperoleh nilai dari suatu variabel bebas. Metode Gauss ini digunakan untuk menyelesaikan sebuah sistem persamaan linier dengan mengubah SPL (Sistem Persamaan Linier) tersebut kedalam bentuk sistem persamaan linier berbentuk segitiga atas, yakni yang semua koefisien dibawah diagonal utamanya bernilai nol. Bentuk segitiga atas ini dapat diselesaikan dengan menggunakan subtitusi. Sebelum merubah menjadi matriks segitiga atas, matriks harus dirubah menjadi augmented matriks : Augmented (A) = [A B] augmented matriks dirubah menjadi matriks segitiga atas dengan menggunakan OBE (Operasi Baris Elementer), seperti persamaan berikut : Maka didapatkan penyeleseaian sebagai berikut : $$ x_{n}= \\frac{b_{n} }{a_{n,n}} $$","title":"Metode Eliminasi Gauss"},{"location":"tugas3/#implementasi-pemrograman","text":"Berikut program untuk persamaan linier dibawah ini: 1 . 3x + y + 2z = 4 2 . 3x + 3y + z = 5 3 . 2x + y + 2z = 2 Listing Program : import numpy as np #Definisi Matrix A = [] B = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) A.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) B.append(h) Matrix=np.array(A,float) Hasil=np.array(B,float) n=len(Matrix) #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) #Subtitusi x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai X ',m+1, '=',x[m]) Output : Masukkan ukuran Matrix : 3 Masukkan Nilai : 3 Masukkan Nilai : 1 Masukkan Nilai : 2 Masukkan Nilai : 3 Masukkan Nilai : 3 Masukkan Nilai : 1 Masukkan Nilai : 2 Masukkan Nilai : 1 Masukkan Nilai : 2 Masukkan Hasil : 4 Masukkan Hasil : 5 Masukkan Hasil : 2 Matrix A : [[ 3. 1. 2. ] [ 0. 2. - 1. ] [ 0. 0. 0.83333333 ]] Nilai X 3 = - 0.9999999999999998 Nilai X 2 = 1.1102230246251565e-16 Nilai X 1 = 2.0","title":"Implementasi Pemrograman"},{"location":"tugas3/#metode-gauss-jacobi","text":"Metode iterasi Jacobi merupakan salah satu metode tak langsung, yang bermula dari suatu hampiran penyelesaian awal dan kemudian memperbaiki hampiran dalam tak berhingga namun langkah kovergen. Metode iterasi Jacobi ini digunakan untuk menyelesaikan persamaan linier berukuran besar dan proporsi keofeisian nolnya besar. Jika diubah dari persamaan linier, maka akan menjadi : Ax=b Ax=b diketahui bahwa matriks A dapat dituliskan sebagai A=L+D+U, dengan L adalah matriks segitiga bawah, D adalah matriks diagonal, dan U adalah matriks segitiga atas. Lalu persamaan tersebut diubah menjadi : $$ Dx + (L + U)x = B $$ x = D^{-1}[b-(L +U)x] x = D^{-1}[b-(L +U)x] Jika ditulis dalam aturan iteratif, maka metode iterai Jacobi dapat ditulis sebagai berikut: $$ X^{(k)}=D^-1(b-(L+U)X^{(k-1)} $$ Dimana k merupakan banyaknya iterasi. Jika x^{(k)} x^{(k)} menyatakan hampiran ke -k -k penyelesaian SPL, maka x^{(0)} x^{(0)} adalah hampiran awal. x_{i}^{(k)}=\\frac{1}{a_{ii}}(\\sum x^{n}_{j\\ne i}),i = 1,2,...n;k=1,2,3,..., x_{i}^{(k)}=\\frac{1}{a_{ii}}(\\sum x^{n}_{j\\ne i}),i = 1,2,...n;k=1,2,3,..., Suatu matriks A berukuran nxn nxn dikatakan dominan secara diagonal apabila : $$ |a_{ii}|>|a_{i,1}|+...+|a_{i,i-1}|+|a_{i,i+1}|+...+|a_{in}| $$ untuk i =1,2,3,...,n i =1,2,3,...,n","title":"Metode Gauss Jacobi"},{"location":"tugas3/#implementasi-pemrograman_1","text":"Berikut program untuk persamaan linier dibawah ini: 1 . 3x + y + 2z = 4 2 . 3x + 3y + z = 5 3 . 2x + y + 2z = 2 Listing Program from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol ) Output: Masukkan ukuran Matrix : 3 Masukkan Nilai : 3 Masukkan Nilai : 1 Masukkan Nilai : 2 Masukkan Nilai : 3 Masukkan Nilai : 3 Masukkan Nilai : 1 Masukkan Nilai : 2 Masukkan Nilai : 1 Masukkan Nilai : 2 Masukkan Hasil : 4 Masukkan Hasil : 5 Masukkan Hasil : 2 A : array ([[ 3. , 1. , 2. ], [ 3. , 3. , 1. ], [ 2. , 1. , 2. ]]) b : array ([ 4. , 5. , 2. ]) x : array ([ 105.35701362 , 119.25506258 , 130.92310531 ])","title":"Implementasi Pemrograman"},{"location":"tugas3/#metode-gauss-seidel","text":"Metode Gauss Seidel digunakan untuk menyelesaikan sistem persamaan linier (SPL) berukuran besar dan proporsi koefisien nolnya besar, seperti sistem-sistem yang banyak ditemukan dalam sistem persamaan diferensial. Metode iterasi Gauss Seidel dikembangkan dari gagasan metode iterasi pada solusi persamaan tak linier. Dengan metode Gauss seidel sesatan pembultan dapat diperkecil karena dapat meneruskan iterasi sampai solusinya seteliti mungkin sesuai dengan batass sesatan yang diperbolehkan. Rumus iterasi untuk hampiran ke-k pada metode Gauss Seidel adalah sebagai berikut. Untuk i=1,2,...,n i=1,2,...,n dan k=1,2,3,... k=1,2,3,... $$ x_{i}^{(k)} = \\frac{1}{a_{ii}}(b_{i} - \\sum_{j=1}^{i-1}a_{ij}x_{j}^{(k)} - \\sum_{j=i+1}^{n}a_{ij}x_{j}^{(k-1)}) $$ dengan syarat a_{ii} \\neq 0 a_{ii} \\neq 0 . Metode iterasi Gauss-Seidel dapat dinyatakan dalam bentuk matriks. Nyatakan matriks koefisien A sebagai A=D+(L+U) A=D+(L+U) , dengan L dan U berturut-turut adalah matriks segitiga bawah dan atas dengandiagonal nol dan D matriks diagonal. Rumus iterasi Gauss-Seidel dapat ditulis dalam bentuk : $$ X^{(k)}=D-1(b-LX^{(k)}-UX^{(k-1)} $$ \\rightarrow (D+L)x^{(k)} = b-Ux^{(k-1)} \\rightarrow (D+L)x^{(k)} = b-Ux^{(k-1)} \\rightarrow x^{(k)} = (D+L)^{-1}(b-Ux^{(k-1)}) \\rightarrow x^{(k)} = (D+L)^{-1}(b-Ux^{(k-1)}) yang menghasilkan: $$ X^{(k)}=(D+L)^{-1} UX^{(k-1)}+(D+L)^{-1}b) $$ Metode iterasi Gauss-Seidel hampir sama dengan metode iterasi Jacobi. Perbedaannya hanya terletak pada penggunaan nilai elemen vektor x^{baru} x^{baru} yang langsung digunakan pada persamaan di bawahnya.","title":"Metode Gauss Seidel"},{"location":"tugas3/#implementasi-pemrograman_2","text":"Berikut program untuk persamaan linier dibawah ini: 1 . 3x + y + 2z = 4 2 . 3x + 3y + z = 5 3 . 2x + y + 2z = 2 Listing Program : def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) print ( x ) Output: Masukkan Panjang Matrix : 3 Masukkan a1 , 1 : 3 Masukkan a1 , 2 : 1 Masukkan a1 , 3 : 2 Masukkan Hasil : 4 Masukkan a2 , 1 : 3 Masukkan a2 , 2 : 3 Masukkan a2 , 3 : 1 Masukkan Hasil : 5 Masukkan a3 , 1 : 2 Masukkan a3 , 2 : 1 Masukkan a3 , 3 : 2 Masukkan Hasil : 2 [ 0 , 0 , 0 ] [ 1.3333333333333333 , 0.3333333333333333 , - 0.4999999999999999 ] [ 1.5555555555555554 , 0.27777777777777796 , - 0.6944444444444443 ] [ 1.7037037037037035 , 0.19444444444444453 , - 0.8009259259259258 ] [ 1.802469135802469 , 0.1311728395061731 , - 0.8680555555555555 ] [ 1.8683127572016458 , 0.08770576131687269 , - 0.9121656378600822 ] [ 1.9122085048010973 , 0.05851337448559687 , - 0.9414651920438957 ] [ 1.941472336534065 , 0.03901606081390022 , - 0.9609803669410151 ] [ 1.9609815576893765 , 0.026011897957628555 , - 0.9739875066681908 ] [ 1.9739877051262509 , 0.017341463763146048 , - 0.982658437007824 ] [ 1.9826584700841672 , 0.011561008918440733 , - 0.9884389745433876 ] [ 1.9884389800561115 , 0.00770734479168426 , - 0.9922926524519536 ] [ 1.9922926533707408 , 0.005138230779910343 , - 0.994861768760696 ] [ 1.994861768913827 , 0.0034254873397382792 , - 0.9965745125836962 ] [ 1.996574512609218 , 0.0022836582520140425 , - 0.997716341735225 ] [ 1.9977163417394788 , 0.0015224388389296628 , - 0.9984775611589436 ] [ 1.9984775611596526 , 0.001014959226661875 , - 0.9989850407729836 ] [ 1.9989850407731018 , 0.000676639484559316 , - 0.9993233605153815 ] [ 1.999323360515401 , 0.00045109298972612066 , - 0.9995489070102641 ] [ 1.9995489070102674 , 0.00030072865982067043 , - 0.9996992713401778 ] [ 1.9996992713401784 , 0.00020048577321415037 , - 0.9997995142267855 ] [ 1.9997995142267857 , 0.0001336571821428656 , - 0.9998663428178571 ] [ 1.9998663428178574 , 8.91047880950957e-05 , - 0.9999108952119049 ] [ 1.9999108952119051 , 5.94031920632491e-05 , - 0.9999405968079368 ] [ 1.999940596807937 , 3.960212804203037e-05 , - 0.9999603978719579 ] [ 1.999960397871958 , 2.6401418694699252e-05 , - 0.9999735985813054 ] [ 1.9999735985813054 , 1.760094579631814e-05 , - 0.9999823990542036 ] [ 1.9999823990542034 , 1.1733963864409466e-05 , - 0.9999882660361356 ] [ 1.9999882660361354 , 7.82264257640867e-06 , - 0.9999921773574236 ] [ 1.9999921773574236 , 5.215095050914442e-06 , - 0.9999947849049491 ] [ 1.999994784904949 , 3.4767300339429616e-06 , - 0.999996523269966 ] [ 1.9999965232699661 , 2.317820022616305e-06 , - 0.9999976821799774 ] [ 1.9999976821799776 , 1.5452133482381687e-06 , - 0.9999984547866517 ] [ 1.9999984547866516 , 1.030142232294473e-06 , - 0.9999989698577678 ] [ 1.9999989698577678 , 6.867614881963154e-07 , - 0.9999993132385119 ] [ 1.999999313238512 , 4.5784099193350397e-07 , - 0.9999995421590081 ] [ 1.9999995421590082 , 3.0522732781997536e-07 , - 0.9999996947726721 ] [ 1.9999996947726721 , 2.0348488523798855e-07 , - 0.9999997965151147 ] [ 1.9999997965151148 , 1.3565659014632322e-07 , - 0.9999998643434099 ] [ 1.99999986434341 , 9.043772660384992e-08 , - 0.9999999095622734 ] [ 1.9999999095622734 , 6.029181776057158e-08 , - 0.9999999397081822 ] [ 1.9999999397081822 , 4.019454517371438e-08 , - 0.9999999598054549 ] [ 1.9999999598054548 , 2.6796363461478734e-08 , - 0.9999999732036364 ] [ 1.9999999732036364 , 1.7864242455682227e-08 , - 0.9999999821357577 ] [ 1.9999999821357577 , 1.1909494797753458e-08 , - 0.999999988090505 ] [ 1.999999988090505 , 7.939663371203665e-09 , - 0.9999999920603367 ] [ 1.9999999920603369 , 5.293108729098606e-09 , - 0.9999999947068912 ] [ 1.9999999947068912 , 3.528739152732404e-09 , - 0.9999999964712607 ] [ 1.9999999964712607 , 2.3524929411896287e-09 , - 0.9999999976475071 ] [ 1.9999999976475074 , 1.5683284300867701e-09 , - 0.9999999984316715 ] [ 1.9999999984316714 , 1.0455524224184387e-09 , - 0.9999999989544477 ] [ 1.9999999989544477 , 6.970349482789592e-10 , - 0.9999999993029651 ] [ 1.9999999993029653 , 4.6468976814632395e-10 , - 0.9999999995353103 ] [ 1.9999999995353104 , 3.097930430702907e-10 , - 0.9999999996902069 ] [ 1.999999999690207 , 2.0652872005181658e-10 , - 0.9999999997934713 ] [ 1.9999999997934712 , 1.3768582570368912e-10 , - 0.9999999998623141 ] [ 1.999999999862314 , 9.179072317048546e-11 , - 0.9999999999082093 ] [ 1.9999999999082094 , 6.119367975306507e-11 , - 0.9999999999388063 ] [ 1.9999999999388063 , 4.079581117366615e-11 , - 0.9999999999592042 ] [ 1.9999999999592042 , 2.7197207449110767e-11 , - 0.9999999999728028 ] [ 1.9999999999728029 , 1.8131459296929126e-11 , - 0.9999999999818686 ] [ 1.9999999999818687 , 1.2087479165738083e-11 , - 0.9999999999879124 ] [ 1.9999999999879126 , 8.058331779636774e-12 , - 0.9999999999919418 ] [ 1.9999999999919418 , 5.372073156687899e-12 , - 0.9999999999946279 ] [ 1.9999999999946276 , 3.581579477440755e-12 , - 0.9999999999964184 ] [ 1.9999999999964182 , 2.3878676813637867e-12 , - 0.9999999999976121 ] [ 1.999999999997612 , 1.5920598173124745e-12 , - 0.9999999999984079 ] [ 1.9999999999984077 , 1.0615212412782664e-12 , - 0.9999999999989385 ] [ 1.9999999999989386 , 7.075451335936123e-13 , - 0.9999999999992923 ] [ 1.9999999999992923 , 4.716967557290749e-13 , - 0.9999999999995282 ] [ 1.9999999999995282 , 3.1463720517876936e-13 , - 0.9999999999996855 ] [ 1.9999999999996856 , 2.095730996150754e-13 , - 0.9999999999997904 ] [ 1.9999999999997904 , 1.3974007136615304e-13 , - 0.9999999999998602 ] [ 1.9999999999998603 , 9.314771176605063e-14 , - 0.999999999999907 ] [ 1.999999999999907 , 6.195044477408373e-14 , - 0.9999999999999379 ] [ 1.9999999999999378 , 4.1485333686826685e-14 , - 0.9999999999999586 ] [ 1.9999999999999585 , 2.7644553313166398e-14 , - 0.9999999999999722 ] [ 1.9999999999999722 , 1.8577731945394287e-14 , - 0.9999999999999816 ] [ 1.9999999999999816 , 1.2212453270876722e-14 , - 0.9999999999999877 ] [ 1.9999999999999876 , 8.326672684688674e-15 , - 0.9999999999999918 ] [ 1.9999999999999918 , 5.551115123125783e-15 , - 0.9999999999999946 ] [ 1.9999999999999947 , 3.515706244646329e-15 , - 0.9999999999999964 ] [ 1.9999999999999964 , 2.3684757858670005e-15 , - 0.9999999999999977 ] [ 1.9999999999999976 , 1.5913196686293911e-15 , - 0.9999999999999983 ] [ 1.9999999999999982 , 1.2212453270876722e-15 , - 0.9999999999999989 ] [ 1.999999999999999 , 8.141635513917814e-16 , - 0.9999999999999993 ] [ 1.9999999999999993 , 3.7007434154171886e-16 , - 0.9999999999999996 ] [ 1.9999999999999993 , 4.440892098500626e-16 , - 0.9999999999999996 ] [ 1.9999999999999993 , 4.440892098500626e-16 , - 0.9999999999999996 ]","title":"Implementasi Pemrograman"},{"location":"tugas4/","text":"Integral Numerik \u00b6 Integral numerik juga dinamakan quadrature , Quadrature pada prinsipnya adalah konsep yang sangat mudah yaitu bagaimana mengevaluasi integral suatu fungsi : I = \\int_{a}^{b} f(x)dx I = \\int_{a}^{b} f(x)dx Dipandang dari sudut persamaan diferensial maka mencari nilai integral I adalah sama dengan menyelesaikan persamaan diferensial : \\frac{dy}{dx} = f(x) \\frac{dy}{dx} = f(x) Dengan syarat batas f(x)=0 f(x)=0 Metode Recursive Trapezoid \u00b6 Metode Recursive Trapezoid merupakan suatu metode pengintegralan dalam analisis numerik.di dalam Kalkulus, integral tentu didefinisikan sebagai sebuah limit jumlah Riemann. Selanjutnya, menurut Teorema Dasar Kalkulus integral tersebut dapat dihitung dengan rumus : \\int_{a}^{b} f(x)dx = F(b) - F(a) \\int_{a}^{b} f(x)dx = F(b) - F(a) Dengan F(x) F(x) adalah antiderivatif f(x) f(x) yakni F'(x) = f(x) F'(x) = f(x) . Banyak integral tentu yang dapat dihitung dengan rumus tesebut, namun demikian, tidak sedikit integral tentu yang tidak dapat dihitung dengan rumus di atas, hal itu dikarenakan integran f(x) f(x) tidak mempunyai antiderivatif yang dapat dinyatakan dalam fungsi-fungsi elementer. Dalam hal ini perhitungan yang dapat dilakukan adalah secara numerik. Misalkan f f adalah suatu fungsi yang terdefinisi pada \\left [ a,b \\right ] \\left [ a,b \\right ] . Misalkan a = x_0 < x_1 < x_2 < ... < x_n a = x_0 < x_1 < x_2 < ... < x_n suatu partisi sedemikian sehingga x_k = x_n + kh x_k = x_n + kh dengan h = (b - a)/n h = (b - a)/n untuk k = 0,1,2,3, .., n k = 0,1,2,3, .., n . Perhatikan aturan trapesium untuk fungsi f f terhadap partisi di atas (untuk keperluan pembahasan pada bagian ini, kita gunakan notasi kuadratur dengan menyertakan cacah dan lebar subinterval) : T_n(f,h) = \\frac{h}{2}(f_0 + 2f_1 + 2f_2 + ... + 2f_{n-1}) + f_n T_n(f,h) = \\frac{h}{2}(f_0 + 2f_1 + 2f_2 + ... + 2f_{n-1}) + f_n \u200b = \\frac{h}{2}(f_0 +f_n) +h(f_1 + f_2 + ... + f_{n-1}) = \\frac{h}{2}(f_0 +f_n) +h(f_1 + f_2 + ... + f_{n-1}) \u200b = \\frac{h}{2}(f_0 +f_n) +h\\sum_{k=1}^{n-1}f_k = \\frac{h}{2}(f_0 +f_n) +h\\sum_{k=1}^{n-1}f_k Sekarang, jika lebar setiap subinterval diperkecil separuhnya, maka dengan : T_0 = T_1(f,h) = \\frac{h}{2}(f(a)+f(b)) T_0 = T_1(f,h) = \\frac{h}{2}(f(a)+f(b)) dan T_k = T_{2^k}(f, \\frac{h}{2^k}), k = 1,2,3, ... T_k = T_{2^k}(f, \\frac{h}{2^k}), k = 1,2,3, ... Barisan aturan trapesium tersebut memenuhi hubungan : T_k + 1 = \\frac{T_k}{2} + \\frac{h}{2^{k+1}}\\sum{j=i}^{2^k}f{2j-i} T_k + 1 = \\frac{T_k}{2} + \\frac{h}{2^{k+1}}\\sum{j=i}^{2^k}f{2j-i} dan f_i = f(a+i\\frac{h}{2^{k+1}}) f_i = f(a+i\\frac{h}{2^{k+1}}) Dalam menghitung hampiran \\int_{a}^{b} f(x)dx \\int_{a}^{b} f(x)dx dengan aturan trapesium rekursif, kita lakukan langkah-langkah sebagai berikut : h = b - 1 h = b - 1 T_0 = \\frac{h}{2}(f(a)+f(b)) T_0 = \\frac{h}{2}(f(a)+f(b)) T_1 = \\frac{T_0}{2} + \\frac{h}{2}f_1 T_1 = \\frac{T_0}{2} + \\frac{h}{2}f_1 T_2 = \\frac{T_1}{2} + \\frac{h}{4}(f_1 + f_3) T_2 = \\frac{T_1}{2} + \\frac{h}{4}(f_1 + f_3) T_3 = \\frac{T_2}{2} + \\frac{h}{8}(f_1 + f_3 + f_5) T_3 = \\frac{T_2}{2} + \\frac{h}{8}(f_1 + f_3 + f_5) Aplikasi Metode Recursive Trapezoid \u00b6 Dengan rumus diatas kita dapat membuat aplikasi dengan cara mengimplementasikannya sebagai berikut: def fungsi ( x ) : y = 1 / ( 1 + x ) return y print ( \"f(x) = 1/(1+x)\" ) a = float ( input ( \"Masukkan batas bawah integral : \" )) b = float ( input ( \"Masukkan batas atas integral : \" )) print ( \"iterasi\" , \"n\" , \"trapesium\" ) for iterasi in range ( 1 , 16 , 1 ): n = 2 * iterasi h = ( b - a ) / n xi = a y = 0 for i in range ( 1 , n ): xi = xi + h y += fungsi ( xi ) hasil = ( h ) * (( fungsi ( a ) + ( 2 * y ) + fungsi ( b )) / 2 ) print ( iterasi , n , hasil ) dengan output : f ( x ) = 1 / ( 1 + x ) Masukkan batas bawah integral : 1 Masukkan batas atas integral : 5 ( 'iterasi' , 'n' , 'trapesium' ) ( 1 , 2 , 1.1666666666666667 ) ( 2 , 4 , 1.1166666666666665 ) ( 3 , 6 , 1.1067460317460316 ) ( 4 , 8 , 1.1032106782106783 ) ( 5 , 10 , 1.1015623265623267 ) ( 6 , 12 , 1.1006636337518692 ) ( 7 , 14 , 1.1001206095246345 ) ( 8 , 16 , 1.0997677015630307 ) ( 9 , 18 , 1.0995255363208654 ) ( 10 , 20 , 1.0993522102854703 ) ( 11 , 22 , 1.0992239111652358 ) ( 12 , 24 , 1.0991262963617388 ) ( 13 , 26 , 1.0990503094436468 ) ( 14 , 28 , 1.098990003895536 ) ( 15 , 30 , 1.0989413445445515 )","title":"Rekursive Trapezoid"},{"location":"tugas4/#integral-numerik","text":"Integral numerik juga dinamakan quadrature , Quadrature pada prinsipnya adalah konsep yang sangat mudah yaitu bagaimana mengevaluasi integral suatu fungsi : I = \\int_{a}^{b} f(x)dx I = \\int_{a}^{b} f(x)dx Dipandang dari sudut persamaan diferensial maka mencari nilai integral I adalah sama dengan menyelesaikan persamaan diferensial : \\frac{dy}{dx} = f(x) \\frac{dy}{dx} = f(x) Dengan syarat batas f(x)=0 f(x)=0","title":"Integral Numerik"},{"location":"tugas4/#metode-recursive-trapezoid","text":"Metode Recursive Trapezoid merupakan suatu metode pengintegralan dalam analisis numerik.di dalam Kalkulus, integral tentu didefinisikan sebagai sebuah limit jumlah Riemann. Selanjutnya, menurut Teorema Dasar Kalkulus integral tersebut dapat dihitung dengan rumus : \\int_{a}^{b} f(x)dx = F(b) - F(a) \\int_{a}^{b} f(x)dx = F(b) - F(a) Dengan F(x) F(x) adalah antiderivatif f(x) f(x) yakni F'(x) = f(x) F'(x) = f(x) . Banyak integral tentu yang dapat dihitung dengan rumus tesebut, namun demikian, tidak sedikit integral tentu yang tidak dapat dihitung dengan rumus di atas, hal itu dikarenakan integran f(x) f(x) tidak mempunyai antiderivatif yang dapat dinyatakan dalam fungsi-fungsi elementer. Dalam hal ini perhitungan yang dapat dilakukan adalah secara numerik. Misalkan f f adalah suatu fungsi yang terdefinisi pada \\left [ a,b \\right ] \\left [ a,b \\right ] . Misalkan a = x_0 < x_1 < x_2 < ... < x_n a = x_0 < x_1 < x_2 < ... < x_n suatu partisi sedemikian sehingga x_k = x_n + kh x_k = x_n + kh dengan h = (b - a)/n h = (b - a)/n untuk k = 0,1,2,3, .., n k = 0,1,2,3, .., n . Perhatikan aturan trapesium untuk fungsi f f terhadap partisi di atas (untuk keperluan pembahasan pada bagian ini, kita gunakan notasi kuadratur dengan menyertakan cacah dan lebar subinterval) : T_n(f,h) = \\frac{h}{2}(f_0 + 2f_1 + 2f_2 + ... + 2f_{n-1}) + f_n T_n(f,h) = \\frac{h}{2}(f_0 + 2f_1 + 2f_2 + ... + 2f_{n-1}) + f_n \u200b = \\frac{h}{2}(f_0 +f_n) +h(f_1 + f_2 + ... + f_{n-1}) = \\frac{h}{2}(f_0 +f_n) +h(f_1 + f_2 + ... + f_{n-1}) \u200b = \\frac{h}{2}(f_0 +f_n) +h\\sum_{k=1}^{n-1}f_k = \\frac{h}{2}(f_0 +f_n) +h\\sum_{k=1}^{n-1}f_k Sekarang, jika lebar setiap subinterval diperkecil separuhnya, maka dengan : T_0 = T_1(f,h) = \\frac{h}{2}(f(a)+f(b)) T_0 = T_1(f,h) = \\frac{h}{2}(f(a)+f(b)) dan T_k = T_{2^k}(f, \\frac{h}{2^k}), k = 1,2,3, ... T_k = T_{2^k}(f, \\frac{h}{2^k}), k = 1,2,3, ... Barisan aturan trapesium tersebut memenuhi hubungan : T_k + 1 = \\frac{T_k}{2} + \\frac{h}{2^{k+1}}\\sum{j=i}^{2^k}f{2j-i} T_k + 1 = \\frac{T_k}{2} + \\frac{h}{2^{k+1}}\\sum{j=i}^{2^k}f{2j-i} dan f_i = f(a+i\\frac{h}{2^{k+1}}) f_i = f(a+i\\frac{h}{2^{k+1}}) Dalam menghitung hampiran \\int_{a}^{b} f(x)dx \\int_{a}^{b} f(x)dx dengan aturan trapesium rekursif, kita lakukan langkah-langkah sebagai berikut : h = b - 1 h = b - 1 T_0 = \\frac{h}{2}(f(a)+f(b)) T_0 = \\frac{h}{2}(f(a)+f(b)) T_1 = \\frac{T_0}{2} + \\frac{h}{2}f_1 T_1 = \\frac{T_0}{2} + \\frac{h}{2}f_1 T_2 = \\frac{T_1}{2} + \\frac{h}{4}(f_1 + f_3) T_2 = \\frac{T_1}{2} + \\frac{h}{4}(f_1 + f_3) T_3 = \\frac{T_2}{2} + \\frac{h}{8}(f_1 + f_3 + f_5) T_3 = \\frac{T_2}{2} + \\frac{h}{8}(f_1 + f_3 + f_5)","title":"Metode Recursive Trapezoid"},{"location":"tugas4/#aplikasi-metode-recursive-trapezoid","text":"Dengan rumus diatas kita dapat membuat aplikasi dengan cara mengimplementasikannya sebagai berikut: def fungsi ( x ) : y = 1 / ( 1 + x ) return y print ( \"f(x) = 1/(1+x)\" ) a = float ( input ( \"Masukkan batas bawah integral : \" )) b = float ( input ( \"Masukkan batas atas integral : \" )) print ( \"iterasi\" , \"n\" , \"trapesium\" ) for iterasi in range ( 1 , 16 , 1 ): n = 2 * iterasi h = ( b - a ) / n xi = a y = 0 for i in range ( 1 , n ): xi = xi + h y += fungsi ( xi ) hasil = ( h ) * (( fungsi ( a ) + ( 2 * y ) + fungsi ( b )) / 2 ) print ( iterasi , n , hasil ) dengan output : f ( x ) = 1 / ( 1 + x ) Masukkan batas bawah integral : 1 Masukkan batas atas integral : 5 ( 'iterasi' , 'n' , 'trapesium' ) ( 1 , 2 , 1.1666666666666667 ) ( 2 , 4 , 1.1166666666666665 ) ( 3 , 6 , 1.1067460317460316 ) ( 4 , 8 , 1.1032106782106783 ) ( 5 , 10 , 1.1015623265623267 ) ( 6 , 12 , 1.1006636337518692 ) ( 7 , 14 , 1.1001206095246345 ) ( 8 , 16 , 1.0997677015630307 ) ( 9 , 18 , 1.0995255363208654 ) ( 10 , 20 , 1.0993522102854703 ) ( 11 , 22 , 1.0992239111652358 ) ( 12 , 24 , 1.0991262963617388 ) ( 13 , 26 , 1.0990503094436468 ) ( 14 , 28 , 1.098990003895536 ) ( 15 , 30 , 1.0989413445445515 )","title":"Aplikasi Metode Recursive Trapezoid"},{"location":"tugas5/","text":"Turunan Numerik \u00b6 Metode Extrapolasi Richardson \u00b6 Metode untuk memperoleh rumus hampiran turunan dengan orde yang lebih tinggi dari hampiran dengan orde yang lebih rendah disebut dengan ekstrapolasi. Metode tersebut dikembangkan oleh Lewis Fry Richardson di awal abad 20, sehingga metode tersebut kemudian dikenal dengan Ekstrapolasi Richardson. Dalam analisis numerik, Extrapolasi Richardson adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergasi suatu urutan. Extrapolasi RIchardson juga dapat diterapkan pada turunan numerik untuk memperoleh solusi yang lebih teliti. Teorema Extrapolasi Richardson \u00b6 Beda terpusat (Central Difference) orde O(h^{2}) O(h^{2}) : $$ {f}'(x)=\\frac{f(x+h)-f(x-h)}{2h}+O(h^{2}) $$ Dari beda terpusat diatas dapat dibuat formula dengan ditetapkan f(x) f(x) dan x x tertentu : \\varnothing(h)=\\frac{f(x+h)-f(x-h)}{2h} \\varnothing(h)=\\frac{f(x+h)-f(x-h)}{2h} \\varnothing(h)={f}'(x)-a_{2}h^{2}-a_{4}h^{4}-a_{6}h^{6}-\\cdots \\varnothing(h)={f}'(x)-a_{2}h^{2}-a_{4}h^{4}-a_{6}h^{6}-\\cdots \\varnothing(\\frac{h}{2})={f}'(x)-a_{2}\\left ( \\frac{h}{2} \\right )^2-a_{4}\\left ( \\frac{h}{2} \\right )^4-a_{6}\\left ( \\frac{h}{2} \\right )^6-\\cdots \\\\ \\varnothing(\\frac{h}{2})={f}'(x)-a_{2}\\left ( \\frac{h}{2} \\right )^2-a_{4}\\left ( \\frac{h}{2} \\right )^4-a_{6}\\left ( \\frac{h}{2} \\right )^6-\\cdots \\\\ \\varnothing(h)-4\\varnothing(\\frac{h}{2})=-3{f}'(x)-\\frac{3}{4}a_{4}h^{4}-\\frac{15}{16}a_{6}h^{6}-\\cdots \\\\ \\varnothing(h)-4\\varnothing(\\frac{h}{2})=-3{f}'(x)-\\frac{3}{4}a_{4}h^{4}-\\frac{15}{16}a_{6}h^{6}-\\cdots \\\\ Maka didapatkan formula baru seperti dibawah ini : $$ f'(x)=\\frac{4}{3}\\varnothing(\\frac {h}{2})-\\frac{1}{3}\\varnothing(h)+O(h^4) $$ Implementasi Pemrograman \u00b6 berikut program untuk f(x) = -0.1x^{4} - 0.15x^{3} - 0.5x^{2} - 0.25x + 1.2 f(x) = -0.1x^{4} - 0.15x^{3} - 0.5x^{2} - 0.25x + 1.2 mulai dengan h_{1}=0.5 h_{1}=0.5 dan h_{2}=0.25 h_{2}=0.25 dan dengan estimasi f'(0.5) f'(0.5) Listing Program from math import * def zeros ( n , m ): Z = [] for i in range ( n ): Z . append ([ 0 ] * m ) return Z def D ( Func , a , h ): return ( Func ( a + h ) - Func ( a - h )) / ( 2 * h ) def Richardson_dif ( func , a ): k = 9 L = zeros ( k , k ) for I in range ( k ): L [ I ][ 0 ] = D ( func , a , 1 / ( 2 ** ( I + 1 ))) for j in range ( 1 , k ): for i in range ( k - j ): L [ i ][ j ] = (( 4 ** ( j )) * L [ i + 1 ][ j - 1 ] - L [ i ][ j - 1 ]) / ( 4 ** ( j ) - 1 ) return L [ 0 ][ k - 1 ] print ( 'f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5' ) print ( 'hasil estimasi =' , ' %04.20f ' % Richardson_dif ( lambda x : - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 , 0.5 )) Output ========================= RESTART : F : \\ richardson . py ========================= f = - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 dengan x = 0.5 hasil estimasi = - 0.91250000000000530687 nilai sesungguhnya dari f'(0.5) = -0,9125 f'(0.5) = -0,9125 . Setelah dihitung menggunakan Richardson Extrapolation menghasilkan nilai yang sama persis.","title":"Metode Extrapolasi Richardson"},{"location":"tugas5/#turunan-numerik","text":"","title":"Turunan Numerik"},{"location":"tugas5/#metode-extrapolasi-richardson","text":"Metode untuk memperoleh rumus hampiran turunan dengan orde yang lebih tinggi dari hampiran dengan orde yang lebih rendah disebut dengan ekstrapolasi. Metode tersebut dikembangkan oleh Lewis Fry Richardson di awal abad 20, sehingga metode tersebut kemudian dikenal dengan Ekstrapolasi Richardson. Dalam analisis numerik, Extrapolasi Richardson adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergasi suatu urutan. Extrapolasi RIchardson juga dapat diterapkan pada turunan numerik untuk memperoleh solusi yang lebih teliti.","title":"Metode Extrapolasi Richardson"},{"location":"tugas5/#teorema-extrapolasi-richardson","text":"Beda terpusat (Central Difference) orde O(h^{2}) O(h^{2}) : $$ {f}'(x)=\\frac{f(x+h)-f(x-h)}{2h}+O(h^{2}) $$ Dari beda terpusat diatas dapat dibuat formula dengan ditetapkan f(x) f(x) dan x x tertentu : \\varnothing(h)=\\frac{f(x+h)-f(x-h)}{2h} \\varnothing(h)=\\frac{f(x+h)-f(x-h)}{2h} \\varnothing(h)={f}'(x)-a_{2}h^{2}-a_{4}h^{4}-a_{6}h^{6}-\\cdots \\varnothing(h)={f}'(x)-a_{2}h^{2}-a_{4}h^{4}-a_{6}h^{6}-\\cdots \\varnothing(\\frac{h}{2})={f}'(x)-a_{2}\\left ( \\frac{h}{2} \\right )^2-a_{4}\\left ( \\frac{h}{2} \\right )^4-a_{6}\\left ( \\frac{h}{2} \\right )^6-\\cdots \\\\ \\varnothing(\\frac{h}{2})={f}'(x)-a_{2}\\left ( \\frac{h}{2} \\right )^2-a_{4}\\left ( \\frac{h}{2} \\right )^4-a_{6}\\left ( \\frac{h}{2} \\right )^6-\\cdots \\\\ \\varnothing(h)-4\\varnothing(\\frac{h}{2})=-3{f}'(x)-\\frac{3}{4}a_{4}h^{4}-\\frac{15}{16}a_{6}h^{6}-\\cdots \\\\ \\varnothing(h)-4\\varnothing(\\frac{h}{2})=-3{f}'(x)-\\frac{3}{4}a_{4}h^{4}-\\frac{15}{16}a_{6}h^{6}-\\cdots \\\\ Maka didapatkan formula baru seperti dibawah ini : $$ f'(x)=\\frac{4}{3}\\varnothing(\\frac {h}{2})-\\frac{1}{3}\\varnothing(h)+O(h^4) $$","title":"Teorema Extrapolasi Richardson"},{"location":"tugas5/#implementasi-pemrograman","text":"berikut program untuk f(x) = -0.1x^{4} - 0.15x^{3} - 0.5x^{2} - 0.25x + 1.2 f(x) = -0.1x^{4} - 0.15x^{3} - 0.5x^{2} - 0.25x + 1.2 mulai dengan h_{1}=0.5 h_{1}=0.5 dan h_{2}=0.25 h_{2}=0.25 dan dengan estimasi f'(0.5) f'(0.5) Listing Program from math import * def zeros ( n , m ): Z = [] for i in range ( n ): Z . append ([ 0 ] * m ) return Z def D ( Func , a , h ): return ( Func ( a + h ) - Func ( a - h )) / ( 2 * h ) def Richardson_dif ( func , a ): k = 9 L = zeros ( k , k ) for I in range ( k ): L [ I ][ 0 ] = D ( func , a , 1 / ( 2 ** ( I + 1 ))) for j in range ( 1 , k ): for i in range ( k - j ): L [ i ][ j ] = (( 4 ** ( j )) * L [ i + 1 ][ j - 1 ] - L [ i ][ j - 1 ]) / ( 4 ** ( j ) - 1 ) return L [ 0 ][ k - 1 ] print ( 'f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5' ) print ( 'hasil estimasi =' , ' %04.20f ' % Richardson_dif ( lambda x : - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 , 0.5 )) Output ========================= RESTART : F : \\ richardson . py ========================= f = - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 dengan x = 0.5 hasil estimasi = - 0.91250000000000530687 nilai sesungguhnya dari f'(0.5) = -0,9125 f'(0.5) = -0,9125 . Setelah dihitung menggunakan Richardson Extrapolation menghasilkan nilai yang sama persis.","title":"Implementasi Pemrograman"},{"location":"tugas6/","text":"Persmaan Differensial Biasa \u00b6 Metode Euler \u00b6 Dalam matematika dan ilmu komputasi, Metode Euler juga disebut metode forward euler adalah prosedur numerik orde pertama untuk menyelesaikan persamaan differensial biasa dengan nilai awal yang diberikan. Metode Euler adalah salah satu dari metode satu langkah yang paling sederhana. Di banding dengan beberapa metode lainnya, metode ini paling kurang teliti. Namun demikian metode ini perlu dipelajari mengingat kesederhanaannya dan mudah pemahamannya sehingga memudahkan dalam memperlajari metode lain yang lebih teliti. Metode Euler merupakan metode paling sederhana yang diturunkan dari deret Taylor. Penyelesaian initial value problems menggunakan metode Euler dilakukan melalui persamaan $$ y_{i+1}=y_{i}+f(x_{i},y_{i})h $$ dimana i i merupakan tahap iterasi Algoritma Metode Euler \u00b6 Tentukan titik awal integrasi x_{0} x_{0} dan y_{0} y_{0} . Tentukan jumlah iterasi n n dan step size h h yang digunakan. Lakukan integrasi menggunakan persamaan diatas. Tugas Pemrograman \u00b6 Buatlah program untuk menyelesaikan persamaan differensial biasa berikut dengan metode Euler \\frac{dy}{dx} = 1+x^{2}, y(1)=-4 \\frac{dy}{dx} = 1+x^{2}, y(1)=-4 Untuk menentukan y(1.01), y(1.02), y(1.03) y(1.01), y(1.02), y(1.03) Listing Program \u00b6 print ( \"f(x,y)=1+x^2\" ) print ( \"yi+1 = y1 + hf(xi+yi)\" ) x1 = float ( input ( \"Masukkan x1= \" )) x2 = float ( input ( \"Masukkan x2= \" )) h = 1.01 - x1 #Langsung diatur sendiri karena yang dicari f(x,y) nilai x-nya=1.01 n = 4 #jumlah x ada 4 yaitu 1, 1.01, 1.02, 1.03 xi = - 4 hasil = xi y = 0 for i in range ( n ): print ( \"hasil dari y\" + str ( i ) + \"= \" + str ( hasil )) hasil = xi + h * ( 1 + ( x1 + y ) ** 2 ) y += h xi = hasil dari listing program diatas terdapat variabel x_{1} x_{1} adalah x x awal dan x_{2} x_{2} adalah x x akhir. x_{i} x_{i} adalah hasil awal yang kemudian akan dimassukkan pada proses iterasi. Karena rumus eurel adalah y_{1}= y_{0}+h(f(x,y)) y_{1}= y_{0}+h(f(x,y)) maka rumus barunya adalah y_{1}=y_{0}+h(1+x^{2}) y_{1}=y_{0}+h(1+x^{2}) . Variabel y digunakan untuk penambahan nilai x x agar selalu bertambah 0.01 0.01","title":"Persamaan Differensial Biasa"},{"location":"tugas6/#persmaan-differensial-biasa","text":"","title":"Persmaan Differensial Biasa"},{"location":"tugas6/#metode-euler","text":"Dalam matematika dan ilmu komputasi, Metode Euler juga disebut metode forward euler adalah prosedur numerik orde pertama untuk menyelesaikan persamaan differensial biasa dengan nilai awal yang diberikan. Metode Euler adalah salah satu dari metode satu langkah yang paling sederhana. Di banding dengan beberapa metode lainnya, metode ini paling kurang teliti. Namun demikian metode ini perlu dipelajari mengingat kesederhanaannya dan mudah pemahamannya sehingga memudahkan dalam memperlajari metode lain yang lebih teliti. Metode Euler merupakan metode paling sederhana yang diturunkan dari deret Taylor. Penyelesaian initial value problems menggunakan metode Euler dilakukan melalui persamaan $$ y_{i+1}=y_{i}+f(x_{i},y_{i})h $$ dimana i i merupakan tahap iterasi","title":"Metode Euler"},{"location":"tugas6/#algoritma-metode-euler","text":"Tentukan titik awal integrasi x_{0} x_{0} dan y_{0} y_{0} . Tentukan jumlah iterasi n n dan step size h h yang digunakan. Lakukan integrasi menggunakan persamaan diatas.","title":"Algoritma Metode Euler"},{"location":"tugas6/#tugas-pemrograman","text":"Buatlah program untuk menyelesaikan persamaan differensial biasa berikut dengan metode Euler \\frac{dy}{dx} = 1+x^{2}, y(1)=-4 \\frac{dy}{dx} = 1+x^{2}, y(1)=-4 Untuk menentukan y(1.01), y(1.02), y(1.03) y(1.01), y(1.02), y(1.03)","title":"Tugas Pemrograman"},{"location":"tugas6/#listing-program","text":"print ( \"f(x,y)=1+x^2\" ) print ( \"yi+1 = y1 + hf(xi+yi)\" ) x1 = float ( input ( \"Masukkan x1= \" )) x2 = float ( input ( \"Masukkan x2= \" )) h = 1.01 - x1 #Langsung diatur sendiri karena yang dicari f(x,y) nilai x-nya=1.01 n = 4 #jumlah x ada 4 yaitu 1, 1.01, 1.02, 1.03 xi = - 4 hasil = xi y = 0 for i in range ( n ): print ( \"hasil dari y\" + str ( i ) + \"= \" + str ( hasil )) hasil = xi + h * ( 1 + ( x1 + y ) ** 2 ) y += h xi = hasil dari listing program diatas terdapat variabel x_{1} x_{1} adalah x x awal dan x_{2} x_{2} adalah x x akhir. x_{i} x_{i} adalah hasil awal yang kemudian akan dimassukkan pada proses iterasi. Karena rumus eurel adalah y_{1}= y_{0}+h(f(x,y)) y_{1}= y_{0}+h(f(x,y)) maka rumus barunya adalah y_{1}=y_{0}+h(1+x^{2}) y_{1}=y_{0}+h(1+x^{2}) . Variabel y digunakan untuk penambahan nilai x x agar selalu bertambah 0.01 0.01","title":"Listing Program"}]}