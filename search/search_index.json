{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Selamat Datang di Halaman Komputasi Numerik \u00b6 Profil \u00b6 Nama: Dewi Puspita Sari NIM: 180411100113 Kelas: Komputasi Numerik 4A Program Studi: Teknik Informatika Dosen Pengampu: Mula'ab, S.Si, M.Kom","title":"Home"},{"location":"#selamat-datang-di-halaman-komputasi-numerik","text":"","title":"Selamat Datang di Halaman Komputasi Numerik"},{"location":"#profil","text":"Nama: Dewi Puspita Sari NIM: 180411100113 Kelas: Komputasi Numerik 4A Program Studi: Teknik Informatika Dosen Pengampu: Mula'ab, S.Si, M.Kom","title":"Profil"},{"location":"Persamaan Non Linier/","text":"Fungsi Persamaan Non Linier dengan Metode Newton Raphson \u00b6 Penyelesaian persamaan non linier adalah penentuan akar-akar persamaan non linier. Dimana akar sebuah persamaan f(x) =0 adalah nilai-nilai x yang menyebabkan nilai f(x) sama dengan nol. Dengan kata lain akar persamaan f(x) adalah titik potong antara kurva f(x) dan sumbu X . Beberapa persamaan polynomial yang sederhana dapat diselesaikan theorema sisa. Sehingga tidak memerlukan metode numerik dalam menyelesaikannya, karena metode analitik dapat dilakukan. Tetapi bagaimana menyelesaikan persamaan \u200b $$ x\u2013 e-x = 0 $$ Tampaknya sederhana, tetapi untuk menyelesaikan persamaan non linier merupakan metode pencarian akar secara berulang-ulang. Secara sederhana, untuk menyelesaikan persamaan non linier dapat dilakukan dengan menggunakan metode tabel atau pembagian area. Dimana untuk x = [ a , b ] atau x di antara a dan b dibagi sebanyak N bagian dan pada masing-masing bagian dihitung nilai f(x) bila ditemukan f(xk)=0 atau mendekati nol maka dikatakan bahwa xk adalah penyelesaian persamaan f(xk)=0 . Bila tidak ada f(xk) yang sama dengan nol, maka dicari nilai f(xk) dan f(xk+1) yang berlawanan tanda, bila tidak ditemukan maka, f(a).f(b)<0 pada range x=[a,b] terdapat akar f(a).f(b)>0 pada range x=[a,b] dikatakan tidak mempunyai akar untuk x = [ a , b ] dan bila ditemukan maka ada 2 pendapat untuk menentukan akar persamaan, yaitu : Akar persamaan ditentukan oleh nilai mana yang lebih dekat, bila |f(xk)| \u2264 |f(xk+1)| maka akarnya xk , dan bila |f(xk+1)|<|f(xk)| maka akarnya xk+1. Akarnya perlu di cari lagi, dengan range x = [ ] xk , xk +1 Metode Newton Raphson \u00b6 Metode newton raphson adalah metode pendekatan yang menggunakan satu titik awal dan mendekatinya dengan memperhatikan slope atau gradien pada titik tersebut. Algoritma Metode Newton Raphson Mendefinisikan fungsi f(x) dan f1(x) Menentukan toleransi error (e) dan iterasi maksimum ( n ) Menentukan nilai pendekatan awal x0 Menghitung f(x0) dan f1(x0) Untuk iterasi I= 1 atau |f(xi)|\u2265 e, akar persamaan adalah nilai xi yang terakhir diperoleh. Algoritma Metode Newton Raphson dengan modifikasi tabel : Mendefinisikan fungsi F(x) Mengambil range nilai x =[ a , b ] dengan jumlah pembagi n Memasukkan torelansi error ( e ) dan masukkan iterasi n Menggunakan algoritma tabel diperoleh titik pendekatan awal x0 dari : F(xk) . F(xk+1)<0 maka x0 = xk Hitung F(x0) dan F1(x0) Bila F ( abs ( F ( x 0 )))< e ,maka pendekatan awal x0 digeser sebesar dx (dimasukkan) x0 = x0 + dx , hitung F(x0) dan F1(x0)* Untuk iterasi I= 1 atau |F(xi)|\u2265 e Akar persamaan adalah x terakhir yang diperoleh. Implementasi import math e = 2.71828 def fungsi ( x ): x = float (( e ** x ) - ( 4 * x )) return x def fungsiturunan ( x ): x = float (( e ** x ) - ( 4 )) return x x = float ( input ( 'Masukkan nilai awal = ' )) error = float ( input ( 'Masukkan nilai error = ' )) perulangan = int ( input ( 'Masukkan maksimal pengulangan = ' )) iterasi = 0 selisih = error + 1 while iterasi <= perulangan and selisih > error : iterasi += 1 f_2 = x - ( fungsi ( x ) / fungsiturunan ( x )) selisih = math . fabs ( f_2 - x ) x = f_2 print ( \"Iterasi ke = \" , iterasi , \", x = \" , f_2 , \", f(\" , f_2 , \") = \" , fungsi ( f_2 ), \", selisih = \" , error ) if iterasi <= perulangan : print ( \"Perulangan Mencapai Batas Maksimal dengan hasil = \" , f_2 ) else : print ( \"Toleransi tidak terpenuhi\" ) Masukkan nilai awal = 1 Masukkan nilai error = 0.0001 Masukkan maksimal pengulangan = 2 Iterasi ke = 1 , x = 0.0 , f ( 0.0 ) = 1.0 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.0 Iterasi ke = 2 , x = 0.3333333333333333 , f ( 0.3333333333333333 ) = 0.06227877883196098 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3333333333333333 Iterasi ke = 3 , x = 0.35724635301940616 , f ( 0.35724635301940616 ) = 0.0004022049593612742 , selisih = 0.0001 Toleransi tidak terpenuhi","title":"Persamaan Non Linier"},{"location":"Persamaan Non Linier/#fungsi-persamaan-non-linier-dengan-metode-newton-raphson","text":"Penyelesaian persamaan non linier adalah penentuan akar-akar persamaan non linier. Dimana akar sebuah persamaan f(x) =0 adalah nilai-nilai x yang menyebabkan nilai f(x) sama dengan nol. Dengan kata lain akar persamaan f(x) adalah titik potong antara kurva f(x) dan sumbu X . Beberapa persamaan polynomial yang sederhana dapat diselesaikan theorema sisa. Sehingga tidak memerlukan metode numerik dalam menyelesaikannya, karena metode analitik dapat dilakukan. Tetapi bagaimana menyelesaikan persamaan \u200b $$ x\u2013 e-x = 0 $$ Tampaknya sederhana, tetapi untuk menyelesaikan persamaan non linier merupakan metode pencarian akar secara berulang-ulang. Secara sederhana, untuk menyelesaikan persamaan non linier dapat dilakukan dengan menggunakan metode tabel atau pembagian area. Dimana untuk x = [ a , b ] atau x di antara a dan b dibagi sebanyak N bagian dan pada masing-masing bagian dihitung nilai f(x) bila ditemukan f(xk)=0 atau mendekati nol maka dikatakan bahwa xk adalah penyelesaian persamaan f(xk)=0 . Bila tidak ada f(xk) yang sama dengan nol, maka dicari nilai f(xk) dan f(xk+1) yang berlawanan tanda, bila tidak ditemukan maka, f(a).f(b)<0 pada range x=[a,b] terdapat akar f(a).f(b)>0 pada range x=[a,b] dikatakan tidak mempunyai akar untuk x = [ a , b ] dan bila ditemukan maka ada 2 pendapat untuk menentukan akar persamaan, yaitu : Akar persamaan ditentukan oleh nilai mana yang lebih dekat, bila |f(xk)| \u2264 |f(xk+1)| maka akarnya xk , dan bila |f(xk+1)|<|f(xk)| maka akarnya xk+1. Akarnya perlu di cari lagi, dengan range x = [ ] xk , xk +1","title":"Fungsi Persamaan Non Linier dengan Metode Newton Raphson"},{"location":"Persamaan Non Linier/#metode-newton-raphson","text":"Metode newton raphson adalah metode pendekatan yang menggunakan satu titik awal dan mendekatinya dengan memperhatikan slope atau gradien pada titik tersebut. Algoritma Metode Newton Raphson Mendefinisikan fungsi f(x) dan f1(x) Menentukan toleransi error (e) dan iterasi maksimum ( n ) Menentukan nilai pendekatan awal x0 Menghitung f(x0) dan f1(x0) Untuk iterasi I= 1 atau |f(xi)|\u2265 e, akar persamaan adalah nilai xi yang terakhir diperoleh. Algoritma Metode Newton Raphson dengan modifikasi tabel : Mendefinisikan fungsi F(x) Mengambil range nilai x =[ a , b ] dengan jumlah pembagi n Memasukkan torelansi error ( e ) dan masukkan iterasi n Menggunakan algoritma tabel diperoleh titik pendekatan awal x0 dari : F(xk) . F(xk+1)<0 maka x0 = xk Hitung F(x0) dan F1(x0) Bila F ( abs ( F ( x 0 )))< e ,maka pendekatan awal x0 digeser sebesar dx (dimasukkan) x0 = x0 + dx , hitung F(x0) dan F1(x0)* Untuk iterasi I= 1 atau |F(xi)|\u2265 e Akar persamaan adalah x terakhir yang diperoleh. Implementasi import math e = 2.71828 def fungsi ( x ): x = float (( e ** x ) - ( 4 * x )) return x def fungsiturunan ( x ): x = float (( e ** x ) - ( 4 )) return x x = float ( input ( 'Masukkan nilai awal = ' )) error = float ( input ( 'Masukkan nilai error = ' )) perulangan = int ( input ( 'Masukkan maksimal pengulangan = ' )) iterasi = 0 selisih = error + 1 while iterasi <= perulangan and selisih > error : iterasi += 1 f_2 = x - ( fungsi ( x ) / fungsiturunan ( x )) selisih = math . fabs ( f_2 - x ) x = f_2 print ( \"Iterasi ke = \" , iterasi , \", x = \" , f_2 , \", f(\" , f_2 , \") = \" , fungsi ( f_2 ), \", selisih = \" , error ) if iterasi <= perulangan : print ( \"Perulangan Mencapai Batas Maksimal dengan hasil = \" , f_2 ) else : print ( \"Toleransi tidak terpenuhi\" ) Masukkan nilai awal = 1 Masukkan nilai error = 0.0001 Masukkan maksimal pengulangan = 2 Iterasi ke = 1 , x = 0.0 , f ( 0.0 ) = 1.0 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.0 Iterasi ke = 2 , x = 0.3333333333333333 , f ( 0.3333333333333333 ) = 0.06227877883196098 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3333333333333333 Iterasi ke = 3 , x = 0.35724635301940616 , f ( 0.35724635301940616 ) = 0.0004022049593612742 , selisih = 0.0001 Toleransi tidak terpenuhi","title":"Metode Newton Raphson"},{"location":"tugas1/","text":"Menghitung Nilai [e^{}] dengan Pendekatan Deret MacLaurin \u00b6 Deret Taylor dan Deret MacLaurin Sebuah fungsi F(x) yang memiliki turunan F^{1}(x),F^{2}(x),F^{3}(x) dan seterusnya kontiyu dalam interval I dan a,xI maka x disekitar a yang [x-a]<f(x) dapat diekspansi kedalam Deret Taylor. Deret Taylor didefinisikan sebagai berikut. $$ (x)=f(a)=\\frac{f^{1}a(x-a)}{1!}+\\frac{f^{2}a(x-a)^2}{2!}+\\frac{x^{3}a(x-a)^3}{3!}...\\frac{f^{n}a(x-a)^n}{n!} $$ Deret MarcLaurin masih berhubungan dengan Deret Taylor. Deret MacLaurin merupakan kasusu dari deret Tayor dengan fungsi yang di ekspansi di sekitar nilai a=0 . Deret MacLaurin disebut sebagai Deret Taylor Baku, sehingga sebagai berikut. $$ f(x)=f(0)+\\frac{f^{1}(0)x}{1!}+\\frac{f^{2}(0)x^2}{2!}+\\frac{f^{3}(0)x^3}{3!}...\\frac{f^{n}(0)x^n}{n!} $$ Dalam deret macLauren yaitu menunjukkan tiap-tiap suku sampai batas yang ditentukan, sehingga akan menghasilkan nilai yang mendekati nilai yang sebenarnya. Deret MacLauren ini di manfaatkan dalam metode numerik untuk menghitung atau menghampiri nilai fungsi susah dihitung secara manual, seperti halnya kita ingin mencari nilai dari sinx, cosx, e^{x}, logx atau ln(x+1) . Kita membutuhkan alat khusus, seperti kalkulator atau tabel khusus untuk mencari nilai-nilai dari fungsi tersebut. Implementasi import math error = 0.001 def percent ( angka ): return str ( round ( angka * 100 , 4 )) + '%' def f ( x ): f_turunan = 1 current = i = 0 iteration = True while iteration : old = current current += ( f_turunan * ( x ** i )) / math . factorial ( i ) #\u03a3f(0)x^i / i! print ( 'f ke-' , i , '=' , f_turunan , ' {e^3x=' , current , '} {Ea=' , current - old , '} {|\u03f5a|%=' , ( current - old ) / current , '|' , percent (( current - old ) / current ), '}' ) if current - old < error : iteration = False else : f_turunan *= 3 i += 1 f ( 1 ) `f ke- 0 = 1 {e^3x= 1.0 } {Ea= 1.0 } {|\u03f5a|%= 1.0 | 100.0% }` `f ke- 1 = 3 {e^3x= 4.0 } {Ea= 3.0 } {|\u03f5a|%= 0.75 | 75.0% }` `f ke- 2 = 9 {e^3x= 8.5 } {Ea= 4.5 } {|\u03f5a|%= 0.5294117647058824 | 52.9412% }` `f ke- 3 = 27 {e^3x= 13.0 } {Ea= 4.5 } {|\u03f5a|%= 0.34615384615384615 | 34.6154% }` `f ke- 4 = 81 {e^3x= 16.375 } {Ea= 3.375 } {|\u03f5a|%= 0.20610687022900764 | 20.6107% }` `f ke- 5 = 243 {e^3x= 18.4 } {Ea= 2.0249999999999986 } {|\u03f5a|%= 0.11005434782608689 | 11.0054% }` `f ke- 6 = 729 {e^3x= 19.412499999999998 } {Ea= 1.0124999999999993 } {|\u03f5a|%= 0.05215711526078554 | 5.2157% }` `f ke- 7 = 2187 {e^3x= 19.846428571428568 } {Ea= 0.4339285714285701 } {|\u03f5a|%= 0.02186431527802765 | 2.1864% }` `f ke- 8 = 6561 {e^3x= 20.009151785714284 } {Ea= 0.162723214285716 } {|\u03f5a|%= 0.008132439397150944 | 0.8132% }` `f ke- 9 = 19683 {e^3x= 20.063392857142855 } {Ea= 0.05424107142857082 } {|\u03f5a|%= 0.0027034844911218605 | 0.2703% }` `f ke- 10 = 59049 {e^3x= 20.079665178571425 } {Ea= 0.016272321428569825 } {|\u03f5a|%= 0.0008103880858499218 | 0.081% }` `f ke- 11 = 177147 {e^3x= 20.08410308441558 } {Ea= 0.004437905844156376 } {|\u03f5a|%= 0.00022096609569784593 | 0.0221% }` `f ke- 12 = 531441 {e^3x= 20.08521256087662 } {Ea= 0.001109476461039094 } {|\u03f5a|%= 5.523847246706314e-05 | 0.0055% }` ` f ke - 13 = 1594323 { e ^ 3 x = 20.08546859390609 } { Ea = 0.0002560330294691937 } { | \u03f5 a |%= 1.2747177307422833e-05 | 0.0013 % }","title":"MacLaurin"},{"location":"tugas1/#menghitung-nilai-91e93-dengan-pendekatan-deret-maclaurin","text":"Deret Taylor dan Deret MacLaurin Sebuah fungsi F(x) yang memiliki turunan F^{1}(x),F^{2}(x),F^{3}(x) dan seterusnya kontiyu dalam interval I dan a,xI maka x disekitar a yang [x-a]<f(x) dapat diekspansi kedalam Deret Taylor. Deret Taylor didefinisikan sebagai berikut. $$ (x)=f(a)=\\frac{f^{1}a(x-a)}{1!}+\\frac{f^{2}a(x-a)^2}{2!}+\\frac{x^{3}a(x-a)^3}{3!}...\\frac{f^{n}a(x-a)^n}{n!} $$ Deret MarcLaurin masih berhubungan dengan Deret Taylor. Deret MacLaurin merupakan kasusu dari deret Tayor dengan fungsi yang di ekspansi di sekitar nilai a=0 . Deret MacLaurin disebut sebagai Deret Taylor Baku, sehingga sebagai berikut. $$ f(x)=f(0)+\\frac{f^{1}(0)x}{1!}+\\frac{f^{2}(0)x^2}{2!}+\\frac{f^{3}(0)x^3}{3!}...\\frac{f^{n}(0)x^n}{n!} $$ Dalam deret macLauren yaitu menunjukkan tiap-tiap suku sampai batas yang ditentukan, sehingga akan menghasilkan nilai yang mendekati nilai yang sebenarnya. Deret MacLauren ini di manfaatkan dalam metode numerik untuk menghitung atau menghampiri nilai fungsi susah dihitung secara manual, seperti halnya kita ingin mencari nilai dari sinx, cosx, e^{x}, logx atau ln(x+1) . Kita membutuhkan alat khusus, seperti kalkulator atau tabel khusus untuk mencari nilai-nilai dari fungsi tersebut. Implementasi import math error = 0.001 def percent ( angka ): return str ( round ( angka * 100 , 4 )) + '%' def f ( x ): f_turunan = 1 current = i = 0 iteration = True while iteration : old = current current += ( f_turunan * ( x ** i )) / math . factorial ( i ) #\u03a3f(0)x^i / i! print ( 'f ke-' , i , '=' , f_turunan , ' {e^3x=' , current , '} {Ea=' , current - old , '} {|\u03f5a|%=' , ( current - old ) / current , '|' , percent (( current - old ) / current ), '}' ) if current - old < error : iteration = False else : f_turunan *= 3 i += 1 f ( 1 ) `f ke- 0 = 1 {e^3x= 1.0 } {Ea= 1.0 } {|\u03f5a|%= 1.0 | 100.0% }` `f ke- 1 = 3 {e^3x= 4.0 } {Ea= 3.0 } {|\u03f5a|%= 0.75 | 75.0% }` `f ke- 2 = 9 {e^3x= 8.5 } {Ea= 4.5 } {|\u03f5a|%= 0.5294117647058824 | 52.9412% }` `f ke- 3 = 27 {e^3x= 13.0 } {Ea= 4.5 } {|\u03f5a|%= 0.34615384615384615 | 34.6154% }` `f ke- 4 = 81 {e^3x= 16.375 } {Ea= 3.375 } {|\u03f5a|%= 0.20610687022900764 | 20.6107% }` `f ke- 5 = 243 {e^3x= 18.4 } {Ea= 2.0249999999999986 } {|\u03f5a|%= 0.11005434782608689 | 11.0054% }` `f ke- 6 = 729 {e^3x= 19.412499999999998 } {Ea= 1.0124999999999993 } {|\u03f5a|%= 0.05215711526078554 | 5.2157% }` `f ke- 7 = 2187 {e^3x= 19.846428571428568 } {Ea= 0.4339285714285701 } {|\u03f5a|%= 0.02186431527802765 | 2.1864% }` `f ke- 8 = 6561 {e^3x= 20.009151785714284 } {Ea= 0.162723214285716 } {|\u03f5a|%= 0.008132439397150944 | 0.8132% }` `f ke- 9 = 19683 {e^3x= 20.063392857142855 } {Ea= 0.05424107142857082 } {|\u03f5a|%= 0.0027034844911218605 | 0.2703% }` `f ke- 10 = 59049 {e^3x= 20.079665178571425 } {Ea= 0.016272321428569825 } {|\u03f5a|%= 0.0008103880858499218 | 0.081% }` `f ke- 11 = 177147 {e^3x= 20.08410308441558 } {Ea= 0.004437905844156376 } {|\u03f5a|%= 0.00022096609569784593 | 0.0221% }` `f ke- 12 = 531441 {e^3x= 20.08521256087662 } {Ea= 0.001109476461039094 } {|\u03f5a|%= 5.523847246706314e-05 | 0.0055% }` ` f ke - 13 = 1594323 { e ^ 3 x = 20.08546859390609 } { Ea = 0.0002560330294691937 } { | \u03f5 a |%= 1.2747177307422833e-05 | 0.0013 % }","title":"Menghitung Nilai [e^{}] dengan Pendekatan Deret MacLaurin"},{"location":"tugas2/","text":"Fungsi Persamaan Non Linier dengan Metode Newton Raphson \u00b6 Penyelesaian persamaan non linier adalah penentuan akar-akar persamaan non linier. Dimana akar sebuah persamaan f(x) =0 adalah nilai-nilai x yang menyebabkan nilai f(x) sama dengan nol. Dengan kata lain akar persamaan f(x) adalah titik potong antara kurva f(x) dan sumbu X . Beberapa persamaan polynomial yang sederhana dapat diselesaikan theorema sisa. Sehingga tidak memerlukan metode numerik dalam menyelesaikannya, karena metode analitik dapat dilakukan. Tetapi bagaimana menyelesaikan persamaan \u200b $$ x\u2013 e-x = 0 $$ Tampaknya sederhana, tetapi untuk menyelesaikan persamaan non linier merupakan metode pencarian akar secara berulang-ulang. Secara sederhana, untuk menyelesaikan persamaan non linier dapat dilakukan dengan menggunakan metode tabel atau pembagian area. Dimana untuk x = [ a , b ] atau x di antara a dan b dibagi sebanyak N bagian dan pada masing-masing bagian dihitung nilai f(x) bila ditemukan f(xk)=0 atau mendekati nol maka dikatakan bahwa xk adalah penyelesaian persamaan f(xk)=0 . Bila tidak ada f(xk) yang sama dengan nol, maka dicari nilai f(xk) dan f(xk+1) yang berlawanan tanda, bila tidak ditemukan maka, f(a).f(b)<0 pada range x=[a,b] terdapat akar f(a).f(b)>0 pada range x=[a,b] dikatakan tidak mempunyai akar untuk x = [ a , b ] dan bila ditemukan maka ada 2 pendapat untuk menentukan akar persamaan, yaitu : Akar persamaan ditentukan oleh nilai mana yang lebih dekat, bila |f(xk)| \u2264 |f(xk+1)| maka akarnya xk , dan bila |f(xk+1)|<|f(xk)| maka akarnya xk+1. Akarnya perlu di cari lagi, dengan range x = [ ] xk , xk +1 Metode Newton Raphson \u00b6 Metode newton raphson adalah metode pendekatan yang menggunakan satu titik awal dan mendekatinya dengan memperhatikan slope atau gradien pada titik tersebut. Algoritma Metode Newton Raphson Mendefinisikan fungsi f(x) dan f1(x) Menentukan toleransi error (e) dan iterasi maksimum ( n ) Menentukan nilai pendekatan awal x0 Menghitung f(x0) dan f1(x0) Untuk iterasi I= 1 atau |f(xi)|\u2265 e, akar persamaan adalah nilai xi yang terakhir diperoleh. $$ x_{n+1} = x_{n} + \\frac{F(x_{n})}{F^{1}(x_{n})} $$ Algoritma Metode Newton Raphson dengan modifikasi tabel : Mendefinisikan fungsi F(x) Mengambil range nilai x =[ a , b ] dengan jumlah pembagi n Memasukkan torelansi error ( e ) dan masukkan iterasi n Menggunakan algoritma tabel diperoleh titik pendekatan awal x0 dari : F(xk) . F(xk+1)<0 maka x0 = xk Hitung F(x0) dan F1(x0) Bila F ( abs ( F ( x 0 )))< e ,maka pendekatan awal x0 digeser sebesar dx (dimasukkan) x0 = x0 + dx , hitung F(x0) dan F1(x0)* Untuk iterasi I= 1 atau |F(xi)|\u2265 e Akar persamaan adalah x terakhir yang diperoleh. #### Implementasi import math e = 2.71828 def fungsi ( x ): x = float (( e ** x ) - ( 4 * x )) return x def fungsiturunan ( x ): x = float (( e ** x ) - ( 4 )) return x x = float ( input ( 'Masukkan nilai awal = ' )) error = float ( input ( 'Masukkan nilai error = ' )) perulangan = int ( input ( 'Masukkan maksimal pengulangan = ' )) iterasi = 0 selisih = error + 1 while iterasi <= perulangan and selisih > error : iterasi += 1 f_2 = x - ( fungsi ( x ) / fungsiturunan ( x )) selisih = math . fabs ( f_2 - x ) x = f_2 print ( \"Iterasi ke = \" , iterasi , \", x = \" , f_2 , \", f(\" , f_2 , \") = \" , fungsi ( f_2 ), \", selisih = \" , error ) if iterasi <= perulangan : print ( \"Perulangan Mencapai Batas Maksimal dengan hasil = \" , f_2 ) else : print ( \"Toleransi tidak terpenuhi\" ) Masukkan nilai awal = 1 Masukkan nilai error = 0.0001 Masukkan maksimal pengulangan = 2 Iterasi ke = 1 , x = 0.0 , f ( 0.0 ) = 1.0 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.0 Iterasi ke = 2 , x = 0.3333333333333333 , f ( 0.3333333333333333 ) = 0.06227877883196098 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3333333333333333 Iterasi ke = 3 , x = 0.35724635301940616 , f ( 0.35724635301940616 ) = 0.0004022049593612742 , selisih = 0.0001 Toleransi tidak terpenuhi Penjelasan \u00b6 Importh Library math karena kita menggunakan contoh fungsi f(x)=ex\u22124Xf(x)=ex\u22124X maka kita membuat sebuah fungsi yang sesuai , dan juga fungsi turunannya yaitu f\u2032(x)=ex\u22124f\u2032(x)=ex\u22124 Membuat sebuah inputan untuk X , Error / Epsilon , serta Maksimal perulangan untuk stopping condition lalu deklarasikan iterasi = 0 untuk perulangan yang ke 0 nantinya dan akan ditambah setiap kali perulangan deklarasikan selisih untuk xb\u2212x0xb\u2212x0 untuk perbandingan lakukan perulangan dengan kondisi iterasi kurang dari sama dengan inputan maksimal iterasi dan selisih lebih dari error / epsilon hitung xbxb dengan rumus yang sudah kita dapatkan sebelumnya lalu lakukan perbandingan jika mencapai nilai True maka toleransi tidak terpenuhi namun perulangan sudah mencapai batas jika pengecekan selisih > error bernilai bernilai True maka toleransi akan terpenuhi dengan nilai error serta fungsi x pada iterasi ke n","title":"Metode Raphson"},{"location":"tugas2/#fungsi-persamaan-non-linier-dengan-metode-newton-raphson","text":"Penyelesaian persamaan non linier adalah penentuan akar-akar persamaan non linier. Dimana akar sebuah persamaan f(x) =0 adalah nilai-nilai x yang menyebabkan nilai f(x) sama dengan nol. Dengan kata lain akar persamaan f(x) adalah titik potong antara kurva f(x) dan sumbu X . Beberapa persamaan polynomial yang sederhana dapat diselesaikan theorema sisa. Sehingga tidak memerlukan metode numerik dalam menyelesaikannya, karena metode analitik dapat dilakukan. Tetapi bagaimana menyelesaikan persamaan \u200b $$ x\u2013 e-x = 0 $$ Tampaknya sederhana, tetapi untuk menyelesaikan persamaan non linier merupakan metode pencarian akar secara berulang-ulang. Secara sederhana, untuk menyelesaikan persamaan non linier dapat dilakukan dengan menggunakan metode tabel atau pembagian area. Dimana untuk x = [ a , b ] atau x di antara a dan b dibagi sebanyak N bagian dan pada masing-masing bagian dihitung nilai f(x) bila ditemukan f(xk)=0 atau mendekati nol maka dikatakan bahwa xk adalah penyelesaian persamaan f(xk)=0 . Bila tidak ada f(xk) yang sama dengan nol, maka dicari nilai f(xk) dan f(xk+1) yang berlawanan tanda, bila tidak ditemukan maka, f(a).f(b)<0 pada range x=[a,b] terdapat akar f(a).f(b)>0 pada range x=[a,b] dikatakan tidak mempunyai akar untuk x = [ a , b ] dan bila ditemukan maka ada 2 pendapat untuk menentukan akar persamaan, yaitu : Akar persamaan ditentukan oleh nilai mana yang lebih dekat, bila |f(xk)| \u2264 |f(xk+1)| maka akarnya xk , dan bila |f(xk+1)|<|f(xk)| maka akarnya xk+1. Akarnya perlu di cari lagi, dengan range x = [ ] xk , xk +1","title":"Fungsi Persamaan Non Linier dengan Metode Newton Raphson"},{"location":"tugas2/#metode-newton-raphson","text":"Metode newton raphson adalah metode pendekatan yang menggunakan satu titik awal dan mendekatinya dengan memperhatikan slope atau gradien pada titik tersebut. Algoritma Metode Newton Raphson Mendefinisikan fungsi f(x) dan f1(x) Menentukan toleransi error (e) dan iterasi maksimum ( n ) Menentukan nilai pendekatan awal x0 Menghitung f(x0) dan f1(x0) Untuk iterasi I= 1 atau |f(xi)|\u2265 e, akar persamaan adalah nilai xi yang terakhir diperoleh. $$ x_{n+1} = x_{n} + \\frac{F(x_{n})}{F^{1}(x_{n})} $$ Algoritma Metode Newton Raphson dengan modifikasi tabel : Mendefinisikan fungsi F(x) Mengambil range nilai x =[ a , b ] dengan jumlah pembagi n Memasukkan torelansi error ( e ) dan masukkan iterasi n Menggunakan algoritma tabel diperoleh titik pendekatan awal x0 dari : F(xk) . F(xk+1)<0 maka x0 = xk Hitung F(x0) dan F1(x0) Bila F ( abs ( F ( x 0 )))< e ,maka pendekatan awal x0 digeser sebesar dx (dimasukkan) x0 = x0 + dx , hitung F(x0) dan F1(x0)* Untuk iterasi I= 1 atau |F(xi)|\u2265 e Akar persamaan adalah x terakhir yang diperoleh. #### Implementasi import math e = 2.71828 def fungsi ( x ): x = float (( e ** x ) - ( 4 * x )) return x def fungsiturunan ( x ): x = float (( e ** x ) - ( 4 )) return x x = float ( input ( 'Masukkan nilai awal = ' )) error = float ( input ( 'Masukkan nilai error = ' )) perulangan = int ( input ( 'Masukkan maksimal pengulangan = ' )) iterasi = 0 selisih = error + 1 while iterasi <= perulangan and selisih > error : iterasi += 1 f_2 = x - ( fungsi ( x ) / fungsiturunan ( x )) selisih = math . fabs ( f_2 - x ) x = f_2 print ( \"Iterasi ke = \" , iterasi , \", x = \" , f_2 , \", f(\" , f_2 , \") = \" , fungsi ( f_2 ), \", selisih = \" , error ) if iterasi <= perulangan : print ( \"Perulangan Mencapai Batas Maksimal dengan hasil = \" , f_2 ) else : print ( \"Toleransi tidak terpenuhi\" ) Masukkan nilai awal = 1 Masukkan nilai error = 0.0001 Masukkan maksimal pengulangan = 2 Iterasi ke = 1 , x = 0.0 , f ( 0.0 ) = 1.0 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.0 Iterasi ke = 2 , x = 0.3333333333333333 , f ( 0.3333333333333333 ) = 0.06227877883196098 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3333333333333333 Iterasi ke = 3 , x = 0.35724635301940616 , f ( 0.35724635301940616 ) = 0.0004022049593612742 , selisih = 0.0001 Toleransi tidak terpenuhi","title":"Metode Newton Raphson"},{"location":"tugas2/#penjelasan","text":"Importh Library math karena kita menggunakan contoh fungsi f(x)=ex\u22124Xf(x)=ex\u22124X maka kita membuat sebuah fungsi yang sesuai , dan juga fungsi turunannya yaitu f\u2032(x)=ex\u22124f\u2032(x)=ex\u22124 Membuat sebuah inputan untuk X , Error / Epsilon , serta Maksimal perulangan untuk stopping condition lalu deklarasikan iterasi = 0 untuk perulangan yang ke 0 nantinya dan akan ditambah setiap kali perulangan deklarasikan selisih untuk xb\u2212x0xb\u2212x0 untuk perbandingan lakukan perulangan dengan kondisi iterasi kurang dari sama dengan inputan maksimal iterasi dan selisih lebih dari error / epsilon hitung xbxb dengan rumus yang sudah kita dapatkan sebelumnya lalu lakukan perbandingan jika mencapai nilai True maka toleransi tidak terpenuhi namun perulangan sudah mencapai batas jika pengecekan selisih > error bernilai bernilai True maka toleransi akan terpenuhi dengan nilai error serta fungsi x pada iterasi ke n","title":"Penjelasan"},{"location":"tugas4/","text":"Integral Numerik \u00b6 Integral numerik juga dinamakan quadrature , Quadrature pada prinsipnya adalah konsep yang sangat mudah yaitu bagaimana mengevaluasi integral suatu fungsi : I = \\int_{a}^{b} f(x)dx I = \\int_{a}^{b} f(x)dx Dipandang dari sudut persamaan diferensial maka mencari nilai integral I adalah sama dengan menyelesaikan persamaan diferensial : \\frac{dy}{dx} = f(x) \\frac{dy}{dx} = f(x) Dengan syarat batas f(x)=0 f(x)=0 Metode Recursive Trapezoid \u00b6 Metode Recursive Trapezoid merupakan suatu metode pengintegralan dalam analisis numerik.di dalam Kalkulus, integral tentu didefinisikan sebagai sebuah limit jumlah Riemann. Selanjutnya, menurut Teorema Dasar Kalkulus integral tersebut dapat dihitung dengan rumus : \\int_{a}^{b} f(x)dx = F(b) - F(a) \\int_{a}^{b} f(x)dx = F(b) - F(a) Dengan F(x) F(x) adalah antiderivatif f(x) f(x) yakni F'(x) = f(x) F'(x) = f(x) . Banyak integral tentu yang dapat dihitung dengan rumus tesebut, namun demikian, tidak sedikit integral tentu yang tidak dapat dihitung dengan rumus di atas, hal itu dikarenakan integran f(x) f(x) tidak mempunyai antiderivatif yang dapat dinyatakan dalam fungsi-fungsi elementer. Dalam hal ini perhitungan yang dapat dilakukan adalah secara numerik. Misalkan f f adalah suatu fungsi yang terdefinisi pada \\left [ a,b \\right ] \\left [ a,b \\right ] . Misalkan a = x_0 < x_1 < x_2 < ... < x_n a = x_0 < x_1 < x_2 < ... < x_n suatu partisi sedemikian sehingga x_k = x_n + kh x_k = x_n + kh dengan h = (b - a)/n h = (b - a)/n untuk k = 0,1,2,3, .., n k = 0,1,2,3, .., n . Perhatikan aturan trapesium untuk fungsi f f terhadap partisi di atas (untuk keperluan pembahasan pada bagian ini, kita gunakan notasi kuadratur dengan menyertakan cacah dan lebar subinterval) : T_n(f,h) = \\frac{h}{2}(f_0 + 2f_1 + 2f_2 + ... + 2f_{n-1}) + f_n T_n(f,h) = \\frac{h}{2}(f_0 + 2f_1 + 2f_2 + ... + 2f_{n-1}) + f_n \u200b = \\frac{h}{2}(f_0 +f_n) +h(f_1 + f_2 + ... + f_{n-1}) = \\frac{h}{2}(f_0 +f_n) +h(f_1 + f_2 + ... + f_{n-1}) \u200b = \\frac{h}{2}(f_0 +f_n) +h\\sum_{k=1}^{n-1}f_k = \\frac{h}{2}(f_0 +f_n) +h\\sum_{k=1}^{n-1}f_k Sekarang, jika lebar setiap subinterval diperkecil separuhnya, maka dengan : T_0 = T_1(f,h) = \\frac{h}{2}(f(a)+f(b)) T_0 = T_1(f,h) = \\frac{h}{2}(f(a)+f(b)) dan T_k = T_{2^k}(f, \\frac{h}{2^k}), k = 1,2,3, ... T_k = T_{2^k}(f, \\frac{h}{2^k}), k = 1,2,3, ... Barisan aturan trapesium tersebut memenuhi hubungan : T_k + 1 = \\frac{T_k}{2} + \\frac{h}{2^{k+1}}\\sum{j=i}^{2^k}f{2j-i} T_k + 1 = \\frac{T_k}{2} + \\frac{h}{2^{k+1}}\\sum{j=i}^{2^k}f{2j-i} dan f_i = f(a+i\\frac{h}{2^{k+1}}) f_i = f(a+i\\frac{h}{2^{k+1}}) Dalam menghitung hampiran \\int_{a}^{b} f(x)dx \\int_{a}^{b} f(x)dx dengan aturan trapesium rekursif, kita lakukan langkah-langkah sebagai berikut : h = b - 1 h = b - 1 T_0 = \\frac{h}{2}(f(a)+f(b)) T_0 = \\frac{h}{2}(f(a)+f(b)) T_1 = \\frac{T_0}{2} + \\frac{h}{2}f_1 T_1 = \\frac{T_0}{2} + \\frac{h}{2}f_1 T_2 = \\frac{T_1}{2} + \\frac{h}{4}(f_1 + f_3) T_2 = \\frac{T_1}{2} + \\frac{h}{4}(f_1 + f_3) T_3 = \\frac{T_2}{2} + \\frac{h}{8}(f_1 + f_3 + f_5) T_3 = \\frac{T_2}{2} + \\frac{h}{8}(f_1 + f_3 + f_5) Aplikasi Metode Recursive Trapezoid \u00b6 Dengan rumus diatas kita dapat membuat aplikasi dengan cara mengimplementasikannya sebagai berikut: def fungsi ( x ) : y = 1 / ( 1 + x ) return y print ( \"f(x) = 1/(1+x)\" ) a = float ( input ( \"Masukkan batas bawah integral : \" )) b = float ( input ( \"Masukkan batas atas integral : \" )) print ( \"iterasi\" , \"n\" , \"trapesium\" ) for iterasi in range ( 1 , 16 , 1 ): n = 2 * iterasi h = ( b - a ) / n xi = a y = 0 for i in range ( 1 , n ): xi = xi + h y += fungsi ( xi ) hasil = ( h ) * (( fungsi ( a ) + ( 2 * y ) + fungsi ( b )) / 2 ) print ( iterasi , n , hasil ) dengan output : f ( x ) = 1 / ( 1 + x ) Masukkan batas bawah integral : 1 Masukkan batas atas integral : 5 ( 'iterasi' , 'n' , 'trapesium' ) ( 1 , 2 , 1.1666666666666667 ) ( 2 , 4 , 1.1166666666666665 ) ( 3 , 6 , 1.1067460317460316 ) ( 4 , 8 , 1.1032106782106783 ) ( 5 , 10 , 1.1015623265623267 ) ( 6 , 12 , 1.1006636337518692 ) ( 7 , 14 , 1.1001206095246345 ) ( 8 , 16 , 1.0997677015630307 ) ( 9 , 18 , 1.0995255363208654 ) ( 10 , 20 , 1.0993522102854703 ) ( 11 , 22 , 1.0992239111652358 ) ( 12 , 24 , 1.0991262963617388 ) ( 13 , 26 , 1.0990503094436468 ) ( 14 , 28 , 1.098990003895536 ) ( 15 , 30 , 1.0989413445445515 )","title":"Rekursive Trapezoid"},{"location":"tugas4/#integral-numerik","text":"Integral numerik juga dinamakan quadrature , Quadrature pada prinsipnya adalah konsep yang sangat mudah yaitu bagaimana mengevaluasi integral suatu fungsi : I = \\int_{a}^{b} f(x)dx I = \\int_{a}^{b} f(x)dx Dipandang dari sudut persamaan diferensial maka mencari nilai integral I adalah sama dengan menyelesaikan persamaan diferensial : \\frac{dy}{dx} = f(x) \\frac{dy}{dx} = f(x) Dengan syarat batas f(x)=0 f(x)=0","title":"Integral Numerik"},{"location":"tugas4/#metode-recursive-trapezoid","text":"Metode Recursive Trapezoid merupakan suatu metode pengintegralan dalam analisis numerik.di dalam Kalkulus, integral tentu didefinisikan sebagai sebuah limit jumlah Riemann. Selanjutnya, menurut Teorema Dasar Kalkulus integral tersebut dapat dihitung dengan rumus : \\int_{a}^{b} f(x)dx = F(b) - F(a) \\int_{a}^{b} f(x)dx = F(b) - F(a) Dengan F(x) F(x) adalah antiderivatif f(x) f(x) yakni F'(x) = f(x) F'(x) = f(x) . Banyak integral tentu yang dapat dihitung dengan rumus tesebut, namun demikian, tidak sedikit integral tentu yang tidak dapat dihitung dengan rumus di atas, hal itu dikarenakan integran f(x) f(x) tidak mempunyai antiderivatif yang dapat dinyatakan dalam fungsi-fungsi elementer. Dalam hal ini perhitungan yang dapat dilakukan adalah secara numerik. Misalkan f f adalah suatu fungsi yang terdefinisi pada \\left [ a,b \\right ] \\left [ a,b \\right ] . Misalkan a = x_0 < x_1 < x_2 < ... < x_n a = x_0 < x_1 < x_2 < ... < x_n suatu partisi sedemikian sehingga x_k = x_n + kh x_k = x_n + kh dengan h = (b - a)/n h = (b - a)/n untuk k = 0,1,2,3, .., n k = 0,1,2,3, .., n . Perhatikan aturan trapesium untuk fungsi f f terhadap partisi di atas (untuk keperluan pembahasan pada bagian ini, kita gunakan notasi kuadratur dengan menyertakan cacah dan lebar subinterval) : T_n(f,h) = \\frac{h}{2}(f_0 + 2f_1 + 2f_2 + ... + 2f_{n-1}) + f_n T_n(f,h) = \\frac{h}{2}(f_0 + 2f_1 + 2f_2 + ... + 2f_{n-1}) + f_n \u200b = \\frac{h}{2}(f_0 +f_n) +h(f_1 + f_2 + ... + f_{n-1}) = \\frac{h}{2}(f_0 +f_n) +h(f_1 + f_2 + ... + f_{n-1}) \u200b = \\frac{h}{2}(f_0 +f_n) +h\\sum_{k=1}^{n-1}f_k = \\frac{h}{2}(f_0 +f_n) +h\\sum_{k=1}^{n-1}f_k Sekarang, jika lebar setiap subinterval diperkecil separuhnya, maka dengan : T_0 = T_1(f,h) = \\frac{h}{2}(f(a)+f(b)) T_0 = T_1(f,h) = \\frac{h}{2}(f(a)+f(b)) dan T_k = T_{2^k}(f, \\frac{h}{2^k}), k = 1,2,3, ... T_k = T_{2^k}(f, \\frac{h}{2^k}), k = 1,2,3, ... Barisan aturan trapesium tersebut memenuhi hubungan : T_k + 1 = \\frac{T_k}{2} + \\frac{h}{2^{k+1}}\\sum{j=i}^{2^k}f{2j-i} T_k + 1 = \\frac{T_k}{2} + \\frac{h}{2^{k+1}}\\sum{j=i}^{2^k}f{2j-i} dan f_i = f(a+i\\frac{h}{2^{k+1}}) f_i = f(a+i\\frac{h}{2^{k+1}}) Dalam menghitung hampiran \\int_{a}^{b} f(x)dx \\int_{a}^{b} f(x)dx dengan aturan trapesium rekursif, kita lakukan langkah-langkah sebagai berikut : h = b - 1 h = b - 1 T_0 = \\frac{h}{2}(f(a)+f(b)) T_0 = \\frac{h}{2}(f(a)+f(b)) T_1 = \\frac{T_0}{2} + \\frac{h}{2}f_1 T_1 = \\frac{T_0}{2} + \\frac{h}{2}f_1 T_2 = \\frac{T_1}{2} + \\frac{h}{4}(f_1 + f_3) T_2 = \\frac{T_1}{2} + \\frac{h}{4}(f_1 + f_3) T_3 = \\frac{T_2}{2} + \\frac{h}{8}(f_1 + f_3 + f_5) T_3 = \\frac{T_2}{2} + \\frac{h}{8}(f_1 + f_3 + f_5)","title":"Metode Recursive Trapezoid"},{"location":"tugas4/#aplikasi-metode-recursive-trapezoid","text":"Dengan rumus diatas kita dapat membuat aplikasi dengan cara mengimplementasikannya sebagai berikut: def fungsi ( x ) : y = 1 / ( 1 + x ) return y print ( \"f(x) = 1/(1+x)\" ) a = float ( input ( \"Masukkan batas bawah integral : \" )) b = float ( input ( \"Masukkan batas atas integral : \" )) print ( \"iterasi\" , \"n\" , \"trapesium\" ) for iterasi in range ( 1 , 16 , 1 ): n = 2 * iterasi h = ( b - a ) / n xi = a y = 0 for i in range ( 1 , n ): xi = xi + h y += fungsi ( xi ) hasil = ( h ) * (( fungsi ( a ) + ( 2 * y ) + fungsi ( b )) / 2 ) print ( iterasi , n , hasil ) dengan output : f ( x ) = 1 / ( 1 + x ) Masukkan batas bawah integral : 1 Masukkan batas atas integral : 5 ( 'iterasi' , 'n' , 'trapesium' ) ( 1 , 2 , 1.1666666666666667 ) ( 2 , 4 , 1.1166666666666665 ) ( 3 , 6 , 1.1067460317460316 ) ( 4 , 8 , 1.1032106782106783 ) ( 5 , 10 , 1.1015623265623267 ) ( 6 , 12 , 1.1006636337518692 ) ( 7 , 14 , 1.1001206095246345 ) ( 8 , 16 , 1.0997677015630307 ) ( 9 , 18 , 1.0995255363208654 ) ( 10 , 20 , 1.0993522102854703 ) ( 11 , 22 , 1.0992239111652358 ) ( 12 , 24 , 1.0991262963617388 ) ( 13 , 26 , 1.0990503094436468 ) ( 14 , 28 , 1.098990003895536 ) ( 15 , 30 , 1.0989413445445515 )","title":"Aplikasi Metode Recursive Trapezoid"},{"location":"tugas5/","text":"Turunan Numerik \u00b6 Metode Extrapolasi Richardson \u00b6 Metode untuk memperoleh rumus hampiran turunan dengan orde yang lebih tinggi dari hampiran dengan orde yang lebih rendah disebut dengan ekstrapolasi. Metode tersebut dikembangkan oleh Lewis Fry Richardson di awal abad 20, sehingga metode tersebut kemudian dikenal dengan Ekstrapolasi Richardson. Dalam analisis numerik, Extrapolasi Richardson adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergasi suatu urutan. Extrapolasi RIchardson juga dapat diterapkan pada turunan numerik untuk memperoleh solusi yang lebih teliti. Teorema Extrapolasi Richardson \u00b6 Beda terpusat (Central Difference) orde O(h^{2}) O(h^{2}) : $$ {f}'(x)=\\frac{f(x+h)-f(x-h)}{2h}+O(h^{2}) $$ Dari beda terpusat diatas dapat dibuat formula dengan ditetapkan f(x) f(x) dan x x tertentu : \\varnothing(h)=\\frac{f(x+h)-f(x-h)}{2h} \\varnothing(h)=\\frac{f(x+h)-f(x-h)}{2h} \\varnothing(h)={f}'(x)-a_{2}h^{2}-a_{4}h^{4}-a_{6}h^{6}-\\cdots \\varnothing(h)={f}'(x)-a_{2}h^{2}-a_{4}h^{4}-a_{6}h^{6}-\\cdots \\varnothing(\\frac{h}{2})={f}'(x)-a_{2}\\left ( \\frac{h}{2} \\right )^2-a_{4}\\left ( \\frac{h}{2} \\right )^4-a_{6}\\left ( \\frac{h}{2} \\right )^6-\\cdots \\\\ \\varnothing(\\frac{h}{2})={f}'(x)-a_{2}\\left ( \\frac{h}{2} \\right )^2-a_{4}\\left ( \\frac{h}{2} \\right )^4-a_{6}\\left ( \\frac{h}{2} \\right )^6-\\cdots \\\\ \\varnothing(h)-4\\varnothing(\\frac{h}{2})=-3{f}'(x)-\\frac{3}{4}a_{4}h^{4}-\\frac{15}{16}a_{6}h^{6}-\\cdots \\\\ \\varnothing(h)-4\\varnothing(\\frac{h}{2})=-3{f}'(x)-\\frac{3}{4}a_{4}h^{4}-\\frac{15}{16}a_{6}h^{6}-\\cdots \\\\ Maka didapatkan formula baru seperti dibawah ini : $$ f'(x)=\\frac{4}{3}\\varnothing(\\frac {h}{2})-\\frac{1}{3}\\varnothing(h)+O(h^4) $$ Implementasi Pemrograman \u00b6 berikut program untuk f(x) = -0.1x^{4} - 0.15x^{3} - 0.5x^{2} - 0.25x + 1.2 f(x) = -0.1x^{4} - 0.15x^{3} - 0.5x^{2} - 0.25x + 1.2 mulai dengan h_{1}=0.5 h_{1}=0.5 dan h_{2}=0.25 h_{2}=0.25 dan dengan estimasi f'(0.5) f'(0.5) Listing Program from math import * def zeros ( n , m ): Z = [] for i in range ( n ): Z . append ([ 0 ] * m ) return Z def D ( Func , a , h ): return ( Func ( a + h ) - Func ( a - h )) / ( 2 * h ) def Richardson_dif ( func , a ): k = 9 L = zeros ( k , k ) for I in range ( k ): L [ I ][ 0 ] = D ( func , a , 1 / ( 2 ** ( I + 1 ))) for j in range ( 1 , k ): for i in range ( k - j ): L [ i ][ j ] = (( 4 ** ( j )) * L [ i + 1 ][ j - 1 ] - L [ i ][ j - 1 ]) / ( 4 ** ( j ) - 1 ) return L [ 0 ][ k - 1 ] print ( 'f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5' ) print ( 'hasil estimasi =' , ' %04.20f ' % Richardson_dif ( lambda x : - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 , 0.5 )) Output ========================= RESTART : F : \\ richardson . py ========================= f = - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 dengan x = 0.5 hasil estimasi = - 0.91250000000000530687 nilai sesungguhnya dari f'(0.5) = -0,9125 f'(0.5) = -0,9125 . Setelah dihitung menggunakan Richardson Extrapolation menghasilkan nilai yang sama persis.","title":"Metode Extrapolasi Richardson"},{"location":"tugas5/#turunan-numerik","text":"","title":"Turunan Numerik"},{"location":"tugas5/#metode-extrapolasi-richardson","text":"Metode untuk memperoleh rumus hampiran turunan dengan orde yang lebih tinggi dari hampiran dengan orde yang lebih rendah disebut dengan ekstrapolasi. Metode tersebut dikembangkan oleh Lewis Fry Richardson di awal abad 20, sehingga metode tersebut kemudian dikenal dengan Ekstrapolasi Richardson. Dalam analisis numerik, Extrapolasi Richardson adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergasi suatu urutan. Extrapolasi RIchardson juga dapat diterapkan pada turunan numerik untuk memperoleh solusi yang lebih teliti.","title":"Metode Extrapolasi Richardson"},{"location":"tugas5/#teorema-extrapolasi-richardson","text":"Beda terpusat (Central Difference) orde O(h^{2}) O(h^{2}) : $$ {f}'(x)=\\frac{f(x+h)-f(x-h)}{2h}+O(h^{2}) $$ Dari beda terpusat diatas dapat dibuat formula dengan ditetapkan f(x) f(x) dan x x tertentu : \\varnothing(h)=\\frac{f(x+h)-f(x-h)}{2h} \\varnothing(h)=\\frac{f(x+h)-f(x-h)}{2h} \\varnothing(h)={f}'(x)-a_{2}h^{2}-a_{4}h^{4}-a_{6}h^{6}-\\cdots \\varnothing(h)={f}'(x)-a_{2}h^{2}-a_{4}h^{4}-a_{6}h^{6}-\\cdots \\varnothing(\\frac{h}{2})={f}'(x)-a_{2}\\left ( \\frac{h}{2} \\right )^2-a_{4}\\left ( \\frac{h}{2} \\right )^4-a_{6}\\left ( \\frac{h}{2} \\right )^6-\\cdots \\\\ \\varnothing(\\frac{h}{2})={f}'(x)-a_{2}\\left ( \\frac{h}{2} \\right )^2-a_{4}\\left ( \\frac{h}{2} \\right )^4-a_{6}\\left ( \\frac{h}{2} \\right )^6-\\cdots \\\\ \\varnothing(h)-4\\varnothing(\\frac{h}{2})=-3{f}'(x)-\\frac{3}{4}a_{4}h^{4}-\\frac{15}{16}a_{6}h^{6}-\\cdots \\\\ \\varnothing(h)-4\\varnothing(\\frac{h}{2})=-3{f}'(x)-\\frac{3}{4}a_{4}h^{4}-\\frac{15}{16}a_{6}h^{6}-\\cdots \\\\ Maka didapatkan formula baru seperti dibawah ini : $$ f'(x)=\\frac{4}{3}\\varnothing(\\frac {h}{2})-\\frac{1}{3}\\varnothing(h)+O(h^4) $$","title":"Teorema Extrapolasi Richardson"},{"location":"tugas5/#implementasi-pemrograman","text":"berikut program untuk f(x) = -0.1x^{4} - 0.15x^{3} - 0.5x^{2} - 0.25x + 1.2 f(x) = -0.1x^{4} - 0.15x^{3} - 0.5x^{2} - 0.25x + 1.2 mulai dengan h_{1}=0.5 h_{1}=0.5 dan h_{2}=0.25 h_{2}=0.25 dan dengan estimasi f'(0.5) f'(0.5) Listing Program from math import * def zeros ( n , m ): Z = [] for i in range ( n ): Z . append ([ 0 ] * m ) return Z def D ( Func , a , h ): return ( Func ( a + h ) - Func ( a - h )) / ( 2 * h ) def Richardson_dif ( func , a ): k = 9 L = zeros ( k , k ) for I in range ( k ): L [ I ][ 0 ] = D ( func , a , 1 / ( 2 ** ( I + 1 ))) for j in range ( 1 , k ): for i in range ( k - j ): L [ i ][ j ] = (( 4 ** ( j )) * L [ i + 1 ][ j - 1 ] - L [ i ][ j - 1 ]) / ( 4 ** ( j ) - 1 ) return L [ 0 ][ k - 1 ] print ( 'f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5' ) print ( 'hasil estimasi =' , ' %04.20f ' % Richardson_dif ( lambda x : - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 , 0.5 )) Output ========================= RESTART : F : \\ richardson . py ========================= f = - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 dengan x = 0.5 hasil estimasi = - 0.91250000000000530687 nilai sesungguhnya dari f'(0.5) = -0,9125 f'(0.5) = -0,9125 . Setelah dihitung menggunakan Richardson Extrapolation menghasilkan nilai yang sama persis.","title":"Implementasi Pemrograman"},{"location":"tugas6/","text":"Persmaan Differensial Biasa \u00b6 Metode Euler \u00b6 Dalam matematika dan ilmu komputasi, Metode Euler juga disebut metode forward euler adalah prosedur numerik orde pertama untuk menyelesaikan persamaan differensial biasa dengan nilai awal yang diberikan. Metode Euler adalah salah satu dari metode satu langkah yang paling sederhana. Di banding dengan beberapa metode lainnya, metode ini paling kurang teliti. Namun demikian metode ini perlu dipelajari mengingat kesederhanaannya dan mudah pemahamannya sehingga memudahkan dalam memperlajari metode lain yang lebih teliti. Metode Euler merupakan metode paling sederhana yang diturunkan dari deret Taylor. Penyelesaian initial value problems menggunakan metode Euler dilakukan melalui persamaan $$ y_{i+1}=y_{i}+f(x_{i},y_{i})h $$ dimana i i merupakan tahap iterasi Algoritma Metode Euler \u00b6 Tentukan titik awal integrasi x_{0} x_{0} dan y_{0} y_{0} . Tentukan jumlah iterasi n n dan step size h h yang digunakan. Lakukan integrasi menggunakan persamaan diatas. Tugas Pemrograman \u00b6 Buatlah program untuk menyelesaikan persamaan differensial biasa berikut dengan metode Euler \\frac{dy}{dx} = 1+x^{2}, y(1)=-4 \\frac{dy}{dx} = 1+x^{2}, y(1)=-4 Untuk menentukan y(1.01), y(1.02), y(1.03) y(1.01), y(1.02), y(1.03) Listing Program \u00b6 print ( \"f(x,y)=1+x^2\" ) print ( \"yi+1 = y1 + hf(xi+yi)\" ) x1 = float ( input ( \"Masukkan x1= \" )) x2 = float ( input ( \"Masukkan x2= \" )) h = 1.01 - x1 #Langsung diatur sendiri karena yang dicari f(x,y) nilai x-nya=1.01 n = 4 #jumlah x ada 4 yaitu 1, 1.01, 1.02, 1.03 xi = - 4 hasil = xi y = 0 for i in range ( n ): print ( \"hasil dari y\" + str ( i ) + \"= \" + str ( hasil )) hasil = xi + h * ( 1 + ( x1 + y ) ** 2 ) y += h xi = hasil dari listing program diatas terdapat variabel x_{1} x_{1} adalah x x awal dan x_{2} x_{2} adalah x x akhir. x_{i} x_{i} adalah hasil awal yang kemudian akan dimassukkan pada proses iterasi. Karena rumus eurel adalah y_{1}= y_{0}+h(f(x,y)) y_{1}= y_{0}+h(f(x,y)) maka rumus barunya adalah y_{1}=y_{0}+h(1+x^{2}) y_{1}=y_{0}+h(1+x^{2}) . Variabel y digunakan untuk penambahan nilai x x agar selalu bertambah 0.01 0.01","title":"Persamaan Differensial Biasa"},{"location":"tugas6/#persmaan-differensial-biasa","text":"","title":"Persmaan Differensial Biasa"},{"location":"tugas6/#metode-euler","text":"Dalam matematika dan ilmu komputasi, Metode Euler juga disebut metode forward euler adalah prosedur numerik orde pertama untuk menyelesaikan persamaan differensial biasa dengan nilai awal yang diberikan. Metode Euler adalah salah satu dari metode satu langkah yang paling sederhana. Di banding dengan beberapa metode lainnya, metode ini paling kurang teliti. Namun demikian metode ini perlu dipelajari mengingat kesederhanaannya dan mudah pemahamannya sehingga memudahkan dalam memperlajari metode lain yang lebih teliti. Metode Euler merupakan metode paling sederhana yang diturunkan dari deret Taylor. Penyelesaian initial value problems menggunakan metode Euler dilakukan melalui persamaan $$ y_{i+1}=y_{i}+f(x_{i},y_{i})h $$ dimana i i merupakan tahap iterasi","title":"Metode Euler"},{"location":"tugas6/#algoritma-metode-euler","text":"Tentukan titik awal integrasi x_{0} x_{0} dan y_{0} y_{0} . Tentukan jumlah iterasi n n dan step size h h yang digunakan. Lakukan integrasi menggunakan persamaan diatas.","title":"Algoritma Metode Euler"},{"location":"tugas6/#tugas-pemrograman","text":"Buatlah program untuk menyelesaikan persamaan differensial biasa berikut dengan metode Euler \\frac{dy}{dx} = 1+x^{2}, y(1)=-4 \\frac{dy}{dx} = 1+x^{2}, y(1)=-4 Untuk menentukan y(1.01), y(1.02), y(1.03) y(1.01), y(1.02), y(1.03)","title":"Tugas Pemrograman"},{"location":"tugas6/#listing-program","text":"print ( \"f(x,y)=1+x^2\" ) print ( \"yi+1 = y1 + hf(xi+yi)\" ) x1 = float ( input ( \"Masukkan x1= \" )) x2 = float ( input ( \"Masukkan x2= \" )) h = 1.01 - x1 #Langsung diatur sendiri karena yang dicari f(x,y) nilai x-nya=1.01 n = 4 #jumlah x ada 4 yaitu 1, 1.01, 1.02, 1.03 xi = - 4 hasil = xi y = 0 for i in range ( n ): print ( \"hasil dari y\" + str ( i ) + \"= \" + str ( hasil )) hasil = xi + h * ( 1 + ( x1 + y ) ** 2 ) y += h xi = hasil dari listing program diatas terdapat variabel x_{1} x_{1} adalah x x awal dan x_{2} x_{2} adalah x x akhir. x_{i} x_{i} adalah hasil awal yang kemudian akan dimassukkan pada proses iterasi. Karena rumus eurel adalah y_{1}= y_{0}+h(f(x,y)) y_{1}= y_{0}+h(f(x,y)) maka rumus barunya adalah y_{1}=y_{0}+h(1+x^{2}) y_{1}=y_{0}+h(1+x^{2}) . Variabel y digunakan untuk penambahan nilai x x agar selalu bertambah 0.01 0.01","title":"Listing Program"}]}